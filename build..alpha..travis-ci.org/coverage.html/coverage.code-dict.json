{"/home/travis/build/npmtest/node-npmtest-falcor/test.js":"/* istanbul instrument in package npmtest_falcor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-falcor/lib.npmtest_falcor.js":"/* istanbul instrument in package npmtest_falcor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_falcor = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_falcor = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-falcor/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-falcor && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_falcor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_falcor\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_falcor.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_falcor.rollup.js'] =\n            local.assetsDict['/assets.npmtest_falcor.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_falcor.__dirname + '/lib.npmtest_falcor.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/index.js":"\"use strict\";\n\nfunction falcor(opts) {\n    return new falcor.Model(opts);\n}\n\nif (typeof Promise === \"function\") {\n    falcor.Promise = Promise;\n} else {\n    falcor.Promise = require(\"promise\");\n}\n\nmodule.exports = falcor;\n\nfalcor.Model = require(\"./Model\");\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/Model.js":"var ModelRoot = require(\"./ModelRoot\");\nvar ModelDataSourceAdapter = require(\"./ModelDataSourceAdapter\");\n\nvar RequestQueue = require(\"./request/RequestQueueRx\");\nvar ModelResponse = require(\"./response/ModelResponse\");\nvar SetResponse = require(\"./response/SetResponse\");\nvar CallResponse = require(\"./response/CallResponse\");\nvar InvalidateResponse = require(\"./response/InvalidateResponse\");\n\nvar ASAPScheduler = require(\"./schedulers/ASAPScheduler\");\nvar TimeoutScheduler = require(\"./schedulers/TimeoutScheduler\");\nvar ImmediateScheduler = require(\"./schedulers/ImmediateScheduler\");\n\nvar arrayClone = require(\"./support/array-clone\");\nvar arraySlice = require(\"./support/array-slice\");\n\nvar collectLru = require(\"./lru/collect\");\nvar pathSyntax = require(\"falcor-path-syntax\");\n\nvar getSize = require(\"./support/getSize\");\nvar isObject = require(\"./support/isObject\");\nvar isFunction = require(\"./support/isFunction\");\nvar isPrimitive = require(\"./support/isPrimitive\");\nvar isJSONEnvelope = require(\"./support/isJSONEnvelope\");\nvar isJSONGraphEnvelope = require(\"./support/isJSONGraphEnvelope\");\n\nvar setCache = require(\"./set/setPathMaps\");\nvar setJSONGraphs = require(\"./set/setJSONGraphs\");\nvar jsong = require(\"falcor-json-graph\");\nvar ID = 0;\nvar validateInput = require(\"./support/validateInput\");\nvar noOp = function() {};\nvar getCache = require(\"./get/getCache\");\nvar get = require(\"./get\");\nvar SET_VALID_INPUT = {\n    pathValue: true,\n    pathSyntax: true,\n    json: true,\n    jsonGraph: true\n};\nvar GET_VALID_INPUT = require(\"./response/get/validInput\");\n\nmodule.exports = Model;\n\nModel.ref = jsong.ref;\nModel.atom = jsong.atom;\nModel.error = jsong.error;\nModel.pathValue = jsong.pathValue;\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n /**\n * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n * @callback Model~errorSelector\n * @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n * @returns {Object} the JSONGraph Error object to store in the Model cache.\n */\n\n /**\n * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n * @callback Model~comparator\n * @param {Object} existingValue - the current value in the Model cache.\n * @param {Object} newValue - the value about to be set into the Model cache.\n * @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n */\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(o) {\n\n    var options = o || {};\n    this._root = options._root || new ModelRoot(options);\n    this._path = options.path || options._path || [];\n    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n    this._source = options.source || options._source;\n    this._request = options.request || options._request || new RequestQueue(this, this._scheduler);\n    this._ID = ID++;\n\n    if (typeof options.maxSize === \"number\") {\n        this._maxSize = options.maxSize;\n    } else {\n        this._maxSize = options._maxSize || Model.prototype._maxSize;\n    }\n\n    if (typeof options.collectRatio === \"number\") {\n        this._collectRatio = options.collectRatio;\n    } else {\n        this._collectRatio = options._collectRatio || Model.prototype._collectRatio;\n    }\n\n    if (options.boxed || options.hasOwnProperty(\"_boxed\")) {\n        this._boxed = options.boxed || options._boxed;\n    }\n\n    if (options.materialized || options.hasOwnProperty(\"_materialized\")) {\n        this._materialized = options.materialized || options._materialized;\n    }\n\n    if (typeof options.treatErrorsAsValues === \"boolean\") {\n        this._treatErrorsAsValues = options.treatErrorsAsValues;\n    } else if (options.hasOwnProperty(\"_treatErrorsAsValues\")) {\n        this._treatErrorsAsValues = options._treatErrorsAsValues;\n    }\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\nModel.prototype._materialized = false;\nModel.prototype._boxed = false;\nModel.prototype._progressive = false;\nModel.prototype._treatErrorsAsValues = false;\nModel.prototype._maxSize = Math.pow(2, 53) - 1;\nModel.prototype._collectRatio = 0.75;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = require(\"./response/get\");\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @private\n * @param {Array.<PathSet>} paths - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype._getWithPaths = require(\"./response/get/getWithPaths\");\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSON>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = function set() {\n    var out = validateInput(arguments, SET_VALID_INPUT, \"set\");\n    if (out !== true) {\n        return new ModelResponse(function(o) {\n            o.onError(out);\n        });\n    }\n    return this._set.apply(this, arguments);\n};\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<Object>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload() {\n    var out = validateInput(arguments, GET_VALID_INPUT, \"preload\");\n    if (out !== true) {\n        return new ModelResponse(function(o) {\n            o.onError(out);\n        });\n    }\n    var args = Array.prototype.slice.call(arguments);\n    var self = this;\n    return new ModelResponse(function(obs) {\n        return self.get.apply(self, args).subscribe(function() {\n        }, function(err) {\n            obs.onError(err);\n        }, function() {\n            obs.onCompleted();\n        });\n    });\n};\n\nModel.prototype._set = function _set() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    var selector = arguments[argsLen - 1];\n    if (isFunction(selector)) {\n        argsLen = argsLen - 1;\n    } else {\n        selector = void 0;\n    }\n    args = new Array(argsLen);\n    while (++argsIdx < argsLen) {\n        args[argsIdx] = arguments[argsIdx];\n    }\n    return SetResponse.create(this, args, selector);\n};\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @returns {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\nModel.prototype.call = function call() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    args = new Array(argsLen);\n    while (++argsIdx < argsLen) {\n        var arg = arguments[argsIdx];\n        args[argsIdx] = arg;\n        var argType = typeof arg;\n        if (argsIdx > 1 && !Array.isArray(arg) ||\n            argsIdx === 0 && !Array.isArray(arg) && argType !== \"string\" ||\n            argsIdx === 1 && !Array.isArray(arg) && !isPrimitive(arg)) {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function(o) {\n                o.onError(new Error(\"Invalid argument\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n\n    return CallResponse.create(this, args);\n};\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    var selector = arguments[argsLen - 1];\n    args = new Array(argsLen);\n    while (++argsIdx < argsLen) {\n        args[argsIdx] = pathSyntax.fromPath(arguments[argsIdx]);\n        if (typeof args[argsIdx] !== \"object\") {\n            throw new Error(\"Invalid argument\");\n        }\n    }\n\n    // creates the obs, subscribes and will throw the errors if encountered.\n    InvalidateResponse.\n        create(this, args, selector).\n        subscribe(noOp, function(e) {\n            throw e;\n        });\n};\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link JSONGraph}. The bound location is never a {@link Reference}: any {@link Reference}s encountered while resolving the bound {@link Path} are always replaced with the {@link Reference}s target value. For subsequent operations on the {@link Model}, all paths will be evaluated relative to the bound path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the same location in the {@link JSONGraph}\n * @method\n * @param {Path} derefPath - the path to the object that the new Model should refer to\n * @param {...PathSet} relativePathsToPreload - paths (relative to the dereference path) to preload before Model is created\n * @return {Observable.<Model>} - an Observable stream with a single value, the dereferenced {@link Model}, or an empty stream if nothing is found at the path\n * @example\nvar model = new falcor.Model({\n  cache: {\n    users: [\n      { $type: \"ref\", value: [\"usersById\", 32] }\n    ],\n    usersById: {\n      32: {\n\tname: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\nmodel.deref([\"users\", 0], \"name\").subscribe(function(userModel){\n  console.log(userModel.getPath());\n});\n\n// prints [\"usersById\", 32] because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.deref = require(\"./deref\");\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.getValue = require(\"./get/getValue\");\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.setValue = require(\"./set/setValue\");\n\n// TODO: Does not throw if given a PathSet rather than a Path, not sure if it should or not.\n// TODO: Doc not accurate? I was able to invoke directly against the Model, perhaps because I don't have a data source?\n// TODO: Not clear on what it means to \"retrieve objects in addition to JSONGraph values\"\n/**\n * Synchronously retrieves a single path from the local {@link Model} only and will not retrieve missing paths from the {@link DataSource}. This method can only be invoked when the {@link Model} does not have a {@link DataSource} or from within a selector function. See {@link Model.prototype.get}. The getValueSync method differs from the asynchronous get methods (ex. get, getValues) in that it can be used to retrieve objects in addition to JSONGraph values.\n * @method\n * @private\n * @arg {Path} path - the path to retrieve\n * @return {*} - the value for the specified path\n */\nModel.prototype._getValueSync = require(\"./get/sync\");\n\nModel.prototype._setValueSync = require(\"./set/sync\");\n\nModel.prototype._derefSync = require(\"./deref/sync\");\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n    var cache = this._root.cache;\n    if (cacheOrJSONGraphEnvelope !== cache) {\n        var modelRoot = this._root;\n        var boundPath = this._path;\n        this._path = [];\n        this._root.cache = {};\n        if (typeof cache !== \"undefined\") {\n            collectLru(modelRoot, modelRoot.expired, getSize(cache), 0);\n        }\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            setJSONGraphs(this, [cacheOrJSONGraphEnvelope]);\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            setCache(this, [cacheOrJSONGraphEnvelope]);\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            setCache(this, [{ json: cacheOrJSONGraphEnvelope }]);\n        }\n        this._path = boundPath;\n    } else if (typeof cache === \"undefined\") {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache(\"genreLists[0...10][0...10].boxshot\")));\n */\nModel.prototype.getCache = function _getCache() {\n    var paths = arraySlice(arguments);\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n\n    var result = [{}];\n    var path = this._path;\n    get.getWithPathsAsJSONGraph(this, paths, result);\n    this._path = path;\n    return result[0].jsonGraph;\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(pathArg) {\n    var path = pathArg && pathSyntax.fromPath(pathArg) || [];\n    if (Array.isArray(path) === false) {\n        throw new Error(\"Model#getVersion must be called with an Array path.\");\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\nModel.prototype._syncCheck = function syncCheck(name) {\n    if (Boolean(this._source) && this._root.syncRefCount <= 0 && this._root.unsafeMode === false) {\n        throw new Error(\"Model#\" + name + \" may only be called within the context of a request selector.\");\n    }\n    return true;\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new Model(this);\n    for (var key in opts) {\n        var value = opts[key];\n        if (value === \"delete\") {\n            delete clone[key];\n        } else {\n            clone[key] = value;\n        }\n    }\n    clone.setCache = void 0;\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelayArg) {\n    var schedulerOrDelay = schedulerOrDelayArg;\n    if (typeof schedulerOrDelay === \"number\") {\n        schedulerOrDelay = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay || !schedulerOrDelay.schedule) {\n        schedulerOrDelay = new ASAPScheduler();\n    }\n    var clone = this._clone();\n    clone._request = new RequestQueue(clone, schedulerOrDelay);\n\n    return clone;\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    var clone = this._clone();\n    clone._request = new RequestQueue(clone, new ImmediateScheduler());\n    return clone;\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({\n        _treatErrorsAsValues: true\n    });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: \"Steve\",\n                surname: \"McGuire\"\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints \"Steve\"\nproxyModel.getValue(\"user.name\").\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: \"delete\"\n    });\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: \"ref\",\n        value: this._path\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar model = new falcor.Model({\n  cache: {\n    users: [\n      { $type: \"ref\", value: [\"usersById\", 32] }\n    ],\n    usersById: {\n      32: {\n\tname: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\nmodel.deref([\"users\", 0], \"name\").subscribe(function(userModel){\n  console.log(userModel.getPath());\n});\n\n// prints [\"usersById\", 32] because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.getPath = function getPath() {\n    return arrayClone(this._path);\n};\n\nModel.prototype._getBoundValue = require(\"./get/getBoundValue\");\nModel.prototype._getVersion = require(\"./get/getVersion\");\nModel.prototype._getValueSync = require(\"./get/getValueSync\");\n\nModel.prototype._getPathValuesAsPathMap = get.getWithPathsAsPathMap;\nModel.prototype._getPathValuesAsJSONG = get.getWithPathsAsJSONGraph;\n\nModel.prototype._setPathValuesAsJSON = require(\"./set/setPathValues\");\nModel.prototype._setPathValuesAsJSONG = require(\"./set/setPathValues\");\nModel.prototype._setPathValuesAsPathMap = require(\"./set/setPathValues\");\nModel.prototype._setPathValuesAsValues = require(\"./set/setPathValues\");\n\nModel.prototype._setPathMapsAsJSON = require(\"./set/setPathMaps\");\nModel.prototype._setPathMapsAsJSONG = require(\"./set/setPathMaps\");\nModel.prototype._setPathMapsAsPathMap = require(\"./set/setPathMaps\");\nModel.prototype._setPathMapsAsValues = require(\"./set/setPathMaps\");\n\nModel.prototype._setJSONGsAsJSON = require(\"./set/setJSONGraphs\");\nModel.prototype._setJSONGsAsJSONG = require(\"./set/setJSONGraphs\");\nModel.prototype._setJSONGsAsPathMap = require(\"./set/setJSONGraphs\");\nModel.prototype._setJSONGsAsValues = require(\"./set/setJSONGraphs\");\n\nModel.prototype._setCache = require(\"./set/setPathMaps\");\n\nModel.prototype._invalidatePathValuesAsJSON = require(\"./invalidate/invalidatePathSets\");\nModel.prototype._invalidatePathMapsAsJSON = require(\"./invalidate/invalidatePathMaps\");\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/ModelRoot.js":"var isFunction = require(\"./support/isFunction\");\nvar hasOwn = require(\"./support/hasOwn\");\nvar ImmediateScheduler = require(\"./schedulers/ImmediateScheduler\");\n\nfunction ModelRoot(o) {\n\n    var options = o || {};\n\n    this.syncRefCount = 0;\n    this.expired = options.expired || [];\n    this.unsafeMode = options.unsafeMode || false;\n    this.collectionScheduler = options.collectionScheduler || new ImmediateScheduler();\n    this.cache = {};\n\n    if (isFunction(options.comparator)) {\n        this.comparator = options.comparator;\n    }\n\n    if (isFunction(options.errorSelector)) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (isFunction(options.onChange)) {\n        this.onChange = options.onChange;\n    }\n}\n\nModelRoot.prototype.errorSelector = function errorSelector(x, y) {\n    return y;\n};\nModelRoot.prototype.comparator = function comparator(cacheNode, messageNode) {\n    if (hasOwn(cacheNode, \"value\") && hasOwn(messageNode, \"value\")) {\n        // They are the same only if the following fields are the same.\n        return cacheNode.value === messageNode.value &&\n            cacheNode.$type === messageNode.$type &&\n            cacheNode.$expires === messageNode.$expires;\n    }\n    return cacheNode === messageNode;\n};\n\nmodule.exports = ModelRoot;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/isFunction.js":"var functionTypeof = \"function\";\n\nmodule.exports = function isFunction(func) {\n    return Boolean(func) && typeof func === functionTypeof;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/hasOwn.js":"var isObject = require(\"./isObject\");\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function(obj, prop) {\n  return isObject(obj) && hasOwn.call(obj, prop);\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/isObject.js":"var objTypeof = \"object\";\nmodule.exports = function isObject(value) {\n    return value !== null && typeof value === objTypeof;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/schedulers/ImmediateScheduler.js":"var Rx = require(\"rx/dist/rx\");\nvar Disposable = Rx.Disposable;\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return Disposable.empty;\n};\n\nImmediateScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {\n    action(this, state);\n    return Disposable.empty;\n};\n\nmodule.exports = ImmediateScheduler;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/ModelDataSourceAdapter.js":"function ModelDataSourceAdapter(model) {\n    this._model = model._materialize().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    var params = [path, args, suffixes].concat(paths);\n    return this._model.call.apply(this._model, params)._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/request/RequestQueueRx.js":"var RequestQueue = require(\"./RequestQueue\");\nvar RequestQueueV2 = require(\"./RequestQueueV2\");\n\nfunction RequestQueueRx(model, scheduler) {\n    this.model = model;\n    this.scheduler = scheduler;\n    this.requests = this._requests = [];\n}\n\n// RX MONKEY PATCH\nRequestQueueRx.prototype.get = RequestQueueV2.prototype.get;\nRequestQueueRx.prototype.removeRequest = RequestQueueV2.prototype.removeRequest;\n\nRequestQueueRx.prototype.set = RequestQueue.prototype.set;\nRequestQueueRx.prototype.call = RequestQueue.prototype.call;\n\nmodule.exports = RequestQueueRx;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/request/RequestQueue.js":"\nvar SetRequest = require(\"./../request/SetRequest\");\n\nvar prefix = require(\"./../internal/prefix\");\nvar getType = require(\"./../support/getType\");\nvar isObject = require(\"./../support/isObject\");\nvar falcorPathUtils = require(\"falcor-path-utils\");\n\n/* eslint-disable no-labels block-scoped-var */\nfunction RequestQueue(model, scheduler) {\n    this.total = 0;\n    this.model = model;\n    this.requests = [];\n    this.scheduler = scheduler;\n}\n\nRequestQueue.prototype.set = function setRequest(jsonGraphEnvelope) {\n    jsonGraphEnvelope.paths = falcorPathUtils.collapse(jsonGraphEnvelope.paths);\n    return SetRequest.create(this.model, jsonGraphEnvelope);\n};\n\nRequestQueue.prototype._remove = function removeRequest(request) {\n    var requests = this.requests;\n    var index = requests.indexOf(request);\n    if (index !== -1) {\n        requests.splice(index, 1);\n    }\n};\n\nRequestQueue.prototype.distributePaths = function distributePathsAcrossRequests(paths, requests, RequestType) {\n\n    var model = this.model;\n    var pathsIndex = -1;\n    var pathsCount = paths.length;\n\n    var requestIndex = -1;\n    var requestCount = requests.length;\n    var participatingRequests = [];\n    var pendingRequest;\n    var request;\n\n    insertPath: while (++pathsIndex < pathsCount) {\n\n        var path = paths[pathsIndex];\n\n        requestIndex = -1;\n\n        while (++requestIndex < requestCount) {\n            request = requests[requestIndex];\n            if (request.insertPath(path, request.pending)) {\n                participatingRequests[requestIndex] = request;\n                continue insertPath;\n            }\n        }\n\n        if (!pendingRequest) {\n            pendingRequest = RequestType.create(this, model, this.total++);\n            requests[requestIndex] = pendingRequest;\n            participatingRequests[requestCount++] = pendingRequest;\n        }\n\n        pendingRequest.insertPath(path, false);\n    }\n\n    var pathRequests = [];\n    var pathRequestsIndex = -1;\n\n    requestIndex = -1;\n\n    while (++requestIndex < requestCount) {\n        request = participatingRequests[requestIndex];\n        if (request != null) {\n            pathRequests[++pathRequestsIndex] = request;\n        }\n    }\n\n    return pathRequests;\n};\n\nRequestQueue.prototype.mergeJSONGraphs = function mergeJSONGraphs(aggregate, response) {\n\n    var depth = 0;\n    var contexts = [];\n    var messages = [];\n    var keystack = [];\n    var latestIndex = aggregate.index;\n    var responseIndex = response.index;\n\n    aggregate.index = Math.max(latestIndex, responseIndex);\n\n    contexts[-1] = aggregate.jsonGraph || {};\n    messages[-1] = response.jsonGraph || {};\n\n    recursing: while (depth > -1) {\n\n        var context = contexts[depth - 1];\n        var message = messages[depth - 1];\n        var keys = keystack[depth - 1] || (keystack[depth - 1] = Object.keys(message));\n\n        while (keys.length > 0) {\n\n            var key = keys.pop();\n\n            if (key[0] === prefix) {\n                continue;\n            }\n\n            if (context.hasOwnProperty(key)) {\n                var node = context[key];\n                var nodeType = getType(node);\n                var messageNode = message[key];\n                var messageType = getType(messageNode);\n                if (isObject(node) && isObject(messageNode) && !nodeType && !messageType) {\n                    contexts[depth] = node;\n                    messages[depth] = messageNode;\n                    depth += 1;\n                    continue recursing;\n                } else if (responseIndex > latestIndex) {\n                    context[key] = messageNode;\n                }\n            } else {\n                context[key] = message[key];\n            }\n        }\n\n        depth -= 1;\n    }\n\n    return aggregate;\n};\n/* eslint-enable */\n\nmodule.exports = RequestQueue;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/request/SetRequest.js":"var Rx = require(\"rx/dist/rx\");\nvar Observer = Rx.Observer;\n\nvar Request = require(\"./../request/Request\");\n\nvar arrayMap = require(\"./../support/array-map\");\n\nvar setJSONGraphs = require(\"./../set/setJSONGraphs\");\nvar setPathValues = require(\"./../set/setPathValues\");\n\nvar emptyArray = new Array(0);\n\nfunction SetRequest() {\n    Request.call(this);\n}\n\nSetRequest.create = function create(model, jsonGraphEnvelope) {\n    var request = new SetRequest();\n    request.model = model;\n    request.jsonGraphEnvelope = jsonGraphEnvelope;\n    return request;\n};\n\nSetRequest.prototype = Object.create(Request.prototype);\nSetRequest.prototype.constructor = SetRequest;\n\nSetRequest.prototype.method = \"set\";\nSetRequest.prototype.insertPath = function() {\n    return false;\n};\nSetRequest.prototype.removePath = function() {\n    return 0;\n};\n\nSetRequest.prototype.getSourceArgs = function getSourceArgs() {\n    return this.jsonGraphEnvelope;\n};\n\nSetRequest.prototype.getSourceObserver = function getSourceObserver(observer) {\n\n    var model = this.model;\n    var bound = model._path;\n    var paths = this.jsonGraphEnvelope.paths;\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n    var comparator = modelRoot.comparator;\n\n    return Request.prototype.getSourceObserver.call(this, Observer.create(\n        function onNext(jsonGraphEnvelope) {\n\n            model._path = emptyArray;\n\n            var successfulPaths = setJSONGraphs(model, [{\n                paths: paths,\n                jsonGraph: jsonGraphEnvelope.jsonGraph\n            }], null, errorSelector, comparator);\n\n            jsonGraphEnvelope.paths = successfulPaths[1];\n\n            model._path = bound;\n\n            observer.onNext(jsonGraphEnvelope);\n        },\n        function onError(error) {\n\n            model._path = emptyArray;\n\n            setPathValues(model, arrayMap(paths, function(path) {\n                return {\n                    path: path,\n                    value: error\n                };\n            }), null, errorSelector, comparator);\n\n            model._path = bound;\n\n            observer.onError(error);\n        },\n        function onCompleted() {\n            observer.onCompleted();\n        }\n    ));\n};\n\nmodule.exports = SetRequest;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/request/Request.js":"var Rx = require(\"rx/dist/rx\");\nvar Observer = Rx.Observer;\nvar Observable = Rx.Observable;\nvar Disposable = Rx.Disposable;\nvar SerialDisposable = Rx.SerialDisposable;\nvar CompositeDisposable = Rx.CompositeDisposable;\nvar InvalidSourceError = require(\"./../errors/InvalidSourceError\");\n\nvar falcorPathUtils = require(\"falcor-path-utils\");\nvar iterateKeySet = falcorPathUtils.iterateKeySet;\n\nfunction Request() {\n    this.length = 0;\n    this.pending = false;\n    this.pathmaps = [];\n    Observable.call(this, this._subscribe);\n}\n\nRequest.create = function create(queue, model, index) {\n    var request = new this();\n    request.queue = queue;\n    request.model = model;\n    request.index = index;\n    return request;\n};\n\nRequest.prototype = Object.create(Observable.prototype);\n\nRequest.prototype.constructor = Request;\n\nRequest.prototype.insertPath = function insertPathIntoRequest(path, union, parentArg, indexArg, countArg) {\n\n    var index = indexArg || 0;\n    var count = countArg || path.length - 1;\n    var parent = parentArg || this.pathmaps[count + 1] || (this.pathmaps[count + 1] = Object.create(null));\n\n    if (parent === void 0 || parent === null) {\n        return false;\n    }\n\n    var key, node;\n    var keySet = path[index];\n    var iteratorNote = {};\n    key = iterateKeySet(keySet, iteratorNote);\n\n    // Determines if the key needs to go through permutation or not.\n    // All object based keys require this.\n\n    do {\n        node = parent[key];\n        if (index < count) {\n            if (node == null) {\n                if (union) {\n                    return false;\n                }\n                node = parent[key] = Object.create(null);\n            }\n            if (this.insertPath(path, union, node, index + 1, count) === false) {\n                return false;\n            }\n        } else {\n            parent[key] = (node || 0) + 1;\n            this.length += 1;\n        }\n\n        if (!iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n    } while (!iteratorNote.done);\n\n    return true;\n};\n\n/* eslint-disable guard-for-in */\nRequest.prototype.removePath = function removePathFromRequest(path, parentArg, indexArg, countArg) {\n\n    var index = indexArg || 0;\n    var count = countArg || path.length - 1;\n    var parent = parentArg || this.pathmaps[count + 1];\n\n    if (parent === void 0 || parent === null) {\n        return true;\n    }\n\n    var key, node, deleted = 0;\n    var keySet = path[index];\n    var iteratorNote = {};\n\n    key = iterateKeySet(keySet, iteratorNote);\n    do {\n        node = parent[key];\n        if (node === void 0 || node === null) {\n            continue;\n        } else if (index < count) {\n            deleted += this.removePath(path, node, index + 1, count);\n            var emptyNodeKey = void 0;\n            for (emptyNodeKey in node) {\n                break;\n            }\n            if (emptyNodeKey === void 0) {\n                delete parent[key];\n            }\n        } else {\n            node = parent[key] = (node || 1) - 1;\n            if (node === 0) {\n                delete parent[key];\n            }\n            deleted += 1;\n            this.length -= 1;\n        }\n\n        if (!iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n    } while (!iteratorNote.done);\n\n    return deleted;\n};\n/* eslint-enable */\n\nRequest.prototype.getSourceObserver = function getSourceObserver(observer) {\n    var request = this;\n    return Observer.create(\n        function onNext(envelope) {\n            envelope.jsonGraph = envelope.jsonGraph ||\n                envelope.jsong ||\n                envelope.values ||\n                envelope.value;\n            envelope.index = request.index;\n            observer.onNext(envelope);\n        },\n        function onError(e) {\n            observer.onError(e);\n        },\n        function onCompleted() {\n            observer.onCompleted();\n        });\n};\n\nRequest.prototype._subscribe = function _subscribe(observer) {\n\n    var request = this;\n    var queue = this.queue;\n\n    request.pending = true;\n\n    var isDisposed = false;\n    var sourceSubscription = new SerialDisposable();\n    var queueDisposable = Disposable.create(function() {\n        if (!isDisposed) {\n            isDisposed = true;\n            if (queue) {\n                queue._remove(request);\n            }\n        }\n    });\n\n    var disposables = new CompositeDisposable(sourceSubscription, queueDisposable);\n\n    try {\n        sourceSubscription.setDisposable(\n            this.model._source[this.method](this.getSourceArgs())\n            .subscribe(this.getSourceObserver(observer)));\n    } catch (e) {\n\n        // We need a way to communicate out to the rest of the world that\n        // this error needs to continue its propagation.\n        throw new InvalidSourceError(e);\n    }\n\n    return disposables;\n};\n\nmodule.exports = Request;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/errors/InvalidSourceError.js":"var NAME = \"InvalidSourceError\";\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n * @private\n */\nfunction InvalidSourceError(error) {\n    this.message = \"An exception was thrown when making a request.\";\n    this.stack = (new Error()).stack;\n    this.innerError = error;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nInvalidSourceError.prototype = new Error();\nInvalidSourceError.prototype.name = NAME;\nInvalidSourceError.is = function(e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = InvalidSourceError;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-utils/lib/index.js":"module.exports = {\n    iterateKeySet: require('./iterateKeySet'),\n    toTree: require('./toTree'),\n    toTreeWithUnion: require('./toTreeWithUnion'),\n    pathsComplementFromTree: require('./pathsComplementFromTree'),\n    pathsComplementFromLengthTree: require('./pathsComplementFromLengthTree'),\n    hasIntersection: require('./hasIntersection'),\n    toPaths: require('./toPaths'),\n    collapse: require('./collapse')\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-utils/lib/iterateKeySet.js":"var isArray = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nmodule.exports = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset, length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                ++note.arrayOffset;\n                nextValue = el;\n            }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n        if (!note.loaded) {\n            initializeRange(keySet, note);\n        }\n        if (note.rangeOffset > note.to) {\n            note.done = true;\n            return undefined;\n        }\n\n        return note.rangeOffset++;\n    }\n\n    // Primitive value\n    else {\n        note.done = true;\n        return keySet;\n    }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to ||\n        (typeof key.length === 'number' &&\n        memo.from + key.length - 1 || 0);\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray(key);\n    note.arrayOffset = 0;\n}\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-utils/lib/toTree.js":"var iterateKeySet = require('./../lib/iterateKeySet');\nvar isArray = Array.isArray;\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\nmodule.exports = function toTree(paths) {\n    return paths.reduce(function(acc, path) {\n        innerToTree(acc, path, 0);\n        return acc;\n    }, {});\n};\n\nfunction innerToTree(seed, path, depth) {\n\n    var keySet = path[depth];\n    var iteratorNote = {};\n    var key;\n    var nextDepth = depth + 1;\n\n    key = iterateKeySet(keySet, iteratorNote);\n\n    do {\n\n        var next = seed[key];\n        if (!next) {\n            if (nextDepth === path.length) {\n                seed[key] = null;\n            } else {\n                next = seed[key] = {};\n            }\n        }\n\n        if (nextDepth < path.length) {\n            innerToTree(next, path, nextDepth);\n        }\n\n        if (!iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n    } while (!iteratorNote.done);\n}\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-utils/lib/toTreeWithUnion.js":"","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-utils/lib/pathsComplementFromTree.js":"var hasIntersection = require('./hasIntersection');\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nmodule.exports = function pathsComplementFromTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        if (!hasIntersection(tree, paths[i], 0)) {\n            out[++outLength] = paths[i];\n        }\n    }\n    return out;\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-utils/lib/hasIntersection.js":"var iterateKeySet = require('./iterateKeySet');\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\nmodule.exports = function hasIntersection(tree, path, depth) {\n    var current = tree;\n    var intersects = true;\n\n    // Continue iteratively going down a path until a complex key is\n    // encountered, then recurse.\n    for (;intersects && depth < path.length; ++depth) {\n        var key = path[depth];\n        var keyType = typeof key;\n\n        // We have to iterate key set\n        if (key && keyType === 'object') {\n            var note = {};\n            var innerKey = iterateKeySet(key, note);\n            var nextDepth = depth + 1;\n\n            // Loop through the innerKeys setting the intersects flag\n            // to each result.  Break out on false.\n            do {\n                var next = current[innerKey];\n                intersects = next !== undefined;\n\n                if (intersects) {\n                    intersects = hasIntersection(next, path, nextDepth);\n                }\n                innerKey = iterateKeySet(key, note);\n            } while (intersects && !note.done);\n\n            // Since we recursed, we shall not pass any further!\n            break;\n        }\n\n        // Its a simple key, just move forward with the testing.\n        current = current[key];\n        intersects = current !== undefined;\n    }\n\n    return intersects;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-utils/lib/pathsComplementFromLengthTree.js":"var hasIntersection = require('./hasIntersection');\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nmodule.exports = function pathsComplementFromLengthTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        var path = paths[i];\n        if (!hasIntersection(tree[path.length], path, 0)) {\n            out[++outLength] = path;\n        }\n    }\n    return out;\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-utils/lib/toPaths.js":"var isArray = Array.isArray;\nvar typeOfObject = \"object\";\n\n/* jshint forin: false */\nmodule.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isNumber(length) && isObject(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var code = getHashCode(String(depth));\n    var subs = Object.create(null);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode,\n        subKeys, subKeysIndex, subKeysCount,\n        subSets, subSetsIndex, subSetsCount,\n        pathset, pathsetIndex, pathsetCount,\n        firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if(subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = getHashCode(code + key + subCode);\n\n            isNumber(key) &&\n                subPath.keys.push(parseInt(key, 10)) ||\n                subPath.keys.push(key);\n        }\n\n        while(++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {\"from\":1, \"to\":6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isNumber(key) /* || hash[key] === true*/ ) {\n            isSparseRange = false;\n            break;\n        }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to \"===\".\n        if (to - from <= keyCount) {\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    for (var key in map) {\n        keys[len++] = key;\n    }\n    if (len > 1) {\n        keys.sort(sort);\n    }\n    return len;\n}\n\nfunction getHashCode(key) {\n    var code = 5381;\n    var index = -1;\n    var count = key.length;\n    while (++index < count) {\n        code = (code << 5) + code + key.charCodeAt(index);\n    }\n    return String(code);\n}\n\n/**\n * Return true if argument is a number or can be cast to a number\n * @private\n */\nfunction isNumber(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-utils/lib/collapse.js":"var toPaths = require('./toPaths');\nvar toTree = require('./toTree');\n\nmodule.exports = function collapse(paths) {\n    var collapseMap = paths.\n        reduce(function(acc, path) {\n            var len = path.length;\n            if (!acc[len]) {\n                acc[len] = [];\n            }\n            acc[len].push(path);\n            return acc;\n        }, {});\n\n    Object.\n        keys(collapseMap).\n        forEach(function(collapseKey) {\n            collapseMap[collapseKey] = toTree(collapseMap[collapseKey]);\n        });\n\n    return toPaths(collapseMap);\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/array-map.js":"module.exports = function arrayMap(array, selector) {\n    var i = -1;\n    var n = array.length;\n    var array2 = new Array(n);\n    while (++i < n) {\n        array2[i] = selector(array[i], i, array);\n    }\n    return array2;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/set/setJSONGraphs.js":"var __key = require(\"./../internal/key\");\nvar __ref = require(\"./../internal/ref\");\nvar __context = require(\"./../internal/context\");\nvar __version = require(\"./../internal/version\");\nvar __refIndex = require(\"./../internal/ref-index\");\nvar __refsLength = require(\"./../internal/refs-length\");\n\nvar $ref = require(\"./../types/ref\");\n\nvar promote = require(\"./../lru/promote\");\nvar isExpired = require(\"./../support/isAlreadyExpired\");\nvar isFunction = require(\"./../support/isFunction\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar expireNode = require(\"./../support/expireNode\");\nvar iterateKeySet = require(\"falcor-path-utils\").iterateKeySet;\nvar incrementVersion = require(\"./../support/incrementVersion\");\nvar mergeJSONGraphNode = require(\"./../support/mergeJSONGraphNode\");\n\n/**\n * Merges a list of JSON Graph Envelopes into a cache JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the PathValues to set.\n * @return {Array.<Path>} - a list of optimized paths for the successfully set values.\n */\n\nmodule.exports = function setJSONGraphs(model, jsonGraphEnvelopes, x, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var cache = modelRoot.cache;\n    var initialVersion = cache[__version];\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(\n                path, 0,\n                cache, cache, cache,\n                jsonGraph, jsonGraph, jsonGraph,\n                requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n        }\n    }\n\n    var newVersion = cache[__version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(\n    path, depth, root, parent, node,\n    messageRoot, messageParent, message,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, false, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n        optimizedPath[optimizedPath.index++] = key;\n        var nextNode = results[0];\n        var nextParent = results[1];\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(\n                    path, depth + 1, root, nextParent, nextNode,\n                    messageRoot, results[3], results[2],\n                    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                    version, expired, lru, comparator, errorSelector\n                );\n            } else {\n                promote(lru, nextNode);\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    root, node, messageRoot, message, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var reference = node.value;\n    optimizedPath.splice(0, optimizedPath.length);\n    optimizedPath.push.apply(optimizedPath, reference);\n\n    if (isExpired(node)) {\n        optimizedPath.index = reference.length;\n        expireNode(node, expired, lru);\n        return [undefined, root, message, messageRoot];\n    }\n\n    promote(lru, node);\n\n    var index = 0;\n    var container = node;\n    var count = reference.length - 1;\n    var parent = node = root;\n    var messageParent = message = messageRoot;\n\n    do {\n        var key = reference[index];\n        var branch = index < count;\n        var results = setNode(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, true, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n        node = results[0];\n        if (isPrimitive(node)) {\n            optimizedPath.index = index;\n            return results;\n        }\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n    } while (index++ < count);\n\n    optimizedPath.index = index;\n\n    if (container[__context] !== node) {\n        var backRefs = node[__refsLength] || 0;\n        node[__refsLength] = backRefs + 1;\n        node[__ref + backRefs] = container;\n        container[__context] = node;\n        container[__refIndex] = backRefs;\n    }\n\n    return [node, parent, message, messageParent];\n}\n\nfunction setNode(\n    root, parent, node, messageRoot, messageParent, message,\n    key, branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            root, node, messageRoot, message, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent, message, messageParent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node[__key];\n        }\n    } else {\n        parent = node;\n        messageParent = message;\n        node = parent[key];\n        message = messageParent && messageParent[key];\n    }\n\n    node = mergeJSONGraphNode(\n        parent, node, message, key, requestedPath, optimizedPath,\n        version, expired, lru, comparator, errorSelector\n    );\n\n    return [node, parent, message, messageParent];\n}\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/key.js":"module.exports = require(\"./../internal/prefix\") + \"key\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/prefix.js":"/**\n * http://en.wikipedia.org/wiki/Delimiter#ASCIIDelimitedText\n * record separator character.\n */\nmodule.exports = String.fromCharCode(30);\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/ref.js":"module.exports = require(\"./../internal/prefix\") + \"ref\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/context.js":"module.exports = require(\"./../internal/prefix\") + \"context\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/version.js":"module.exports = require(\"./../internal/prefix\") + \"version\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/ref-index.js":"module.exports = require(\"./../internal/prefix\") + \"ref-index\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/refs-length.js":"module.exports = require(\"./../internal/prefix\") + \"refs-length\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/types/ref.js":"module.exports = \"ref\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/lru/promote.js":"var $expiresNever = require(\"./../values/expires-never\");\nvar __head = require(\"./../internal/head\");\nvar __tail = require(\"./../internal/tail\");\nvar __next = require(\"./../internal/next\");\nvar __prev = require(\"./../internal/prev\");\n\nvar isObject = require(\"./../support/isObject\");\n\nmodule.exports = function lruPromote(root, node) {\n\n    if (isObject(node) && (node.$expires !== $expiresNever)) {\n\n        var head = root[__head],\n            tail = root[__tail],\n            next = node[__next],\n            prev = node[__prev];\n\n        if (node !== head) {\n\n            if (next != null && typeof next === \"object\") {\n                next[__prev] = prev;\n            }\n\n            if (prev != null && typeof prev === \"object\") {\n                prev[__next] = next;\n            }\n\n            next = head;\n\n            if (head != null && typeof head === \"object\") {\n                head[__prev] = node;\n            }\n\n            root[__head] = root[__next] = head = node;\n            head[__next] = next;\n            head[__prev] = void 0;\n        }\n\n        if (tail == null || node === tail) {\n            root[__tail] = root[__prev] = tail = prev || node;\n        }\n    }\n    return node;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/values/expires-never.js":"module.exports = 1;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/head.js":"module.exports = require(\"./../internal/prefix\") + \"head\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/tail.js":"module.exports = require(\"./../internal/prefix\") + \"tail\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/next.js":"module.exports = require(\"./../internal/prefix\") + \"next\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/prev.js":"module.exports = require(\"./../internal/prefix\") + \"prev\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/isAlreadyExpired.js":"var now = require(\"./../support/now\");\nvar $now = require(\"./../values/expires-now\");\nvar $never = require(\"./../values/expires-never\");\n\nmodule.exports = function isAlreadyExpired(node) {\n    var exp = node.$expires;\n    return (exp != null) && (\n        exp !== $never) && (\n        exp !== $now) && (\n        exp < now());\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/now.js":"module.exports = Date.now;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/values/expires-now.js":"module.exports = 0;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/isPrimitive.js":"var objTypeof = \"object\";\nmodule.exports = function isPrimitive(value) {\n    return value == null || typeof value !== objTypeof;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/expireNode.js":"var splice = require(\"./../lru/splice\");\nvar __invalidated = require(\"./../internal/invalidated\");\n\nmodule.exports = function expireNode(node, expired, lru) {\n    if (!node[__invalidated]) {\n        node[__invalidated] = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/lru/splice.js":"var __head = require(\"./../internal/head\");\nvar __tail = require(\"./../internal/tail\");\nvar __next = require(\"./../internal/next\");\nvar __prev = require(\"./../internal/prev\");\n\nmodule.exports = function lruSplice(root, node) {\n\n    var head = root[__head],\n        tail = root[__tail],\n        next = node[__next],\n        prev = node[__prev];\n\n    if (next != null && typeof next === \"object\") {\n        next[__prev] = prev;\n    }\n\n    if (prev != null && typeof prev === \"object\") {\n        prev[__next] = next;\n    }\n\n    if (node === head) {\n        root[__head] = root[__next] = next;\n    }\n\n    if (node === tail) {\n        root[__tail] = root[__prev] = prev;\n    }\n\n    node[__next] = node[__prev] = void 0;\n    head = tail = next = prev = void 0;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/invalidated.js":"module.exports = require(\"./../internal/prefix\") + \"invalidated\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/incrementVersion.js":"var version = 1;\nmodule.exports = function incrementVersion() {\n    return version++;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/mergeJSONGraphNode.js":"var __key = require(\"./../internal/key\");\nvar __parent = require(\"./../internal/parent\");\n\nvar $ref = require(\"./../types/ref\");\nvar $error = require(\"./../types/error\");\nvar getSize = require(\"./../support/getSize\");\nvar getTimestamp = require(\"./../support/getTimestamp\");\nvar isObject = require(\"./../support/isObject\");\nvar isExpired = require(\"./../support/isExpired\");\nvar isFunction = require(\"./../support/isFunction\");\n\nvar promote = require(\"./../lru/promote\");\nvar wrapNode = require(\"./../support/wrapNode\");\nvar insertNode = require(\"./../support/insertNode\");\nvar expireNode = require(\"./../support/expireNode\");\nvar replaceNode = require(\"./../support/replaceNode\");\nvar updateNodeAncestors = require(\"./../support/updateNodeAncestors\");\nvar reconstructPath = require(\"./../support/reconstructPath\");\n\nmodule.exports = function mergeJSONGraphNode(\n    parent, node, message, key, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var sizeOffset;\n\n    var cType, mType,\n        cIsObject, mIsObject,\n        cTimestamp, mTimestamp;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (node === message) {\n\n        // There should not be undefined values.  Those should always be\n        // wrapped in an $atom\n        if (message === null) {\n            node = wrapNode(message, undefined, message);\n            parent = updateNodeAncestors(parent, -node.$size, lru, version);\n            node = insertNode(node, parent, key);\n            promote(lru, node);\n            return node;\n        }\n\n        // The messange and cache are both undefined, therefore return null.\n        else if (message === undefined) {\n            return message;\n        }\n\n        else {\n            cIsObject = isObject(node);\n            if (cIsObject) {\n                // Is the cache node a branch? If so, return the cache branch.\n                cType = node.$type;\n                if (cType == null) {\n                    // Has the branch been introduced to the cache yet? If not,\n                    // give it a parent and key.\n                    if (node[__parent] == null) {\n                        node[__key] = key;\n                        node[__parent] = parent;\n                    }\n                    return node;\n                }\n            }\n        }\n    } else {\n        cIsObject = isObject(node);\n        if (cIsObject) {\n            cType = node.$type;\n        }\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== $ref) {\n        mIsObject = isObject(message);\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || (mIsObject && !mType)) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n        // If the cache is a reference, but the message is empty, leave the cache alone...\n        if (message == null) {\n            // ...unless the cache is an expired reference. In that case, expire\n            // the cache node and return undefined.\n            if (isExpired(node)) {\n                expireNode(node, expired, lru);\n                return void 0;\n            }\n            return node;\n        }\n        mIsObject = isObject(message);\n        if (mIsObject) {\n            mType = message.$type;\n            // If the cache and the message are both references,\n            // check if we need to replace the cache reference.\n            if (mType === $ref) {\n                if (node === message) {\n                    // If the cache and message are the same reference,\n                    // we performed a whole-branch merge of one of the\n                    // grandparents. If we've previously graphed this\n                    // reference, break early. Otherwise, continue to\n                    // leaf insertion below.\n                    if (node[__parent] != null) {\n                        return node;\n                    }\n                } else {\n\n                    cTimestamp = node.$timestamp;\n                    mTimestamp = message.$timestamp;\n\n                    // - If either the cache or message reference is expired,\n                    //   replace the cache reference with the message.\n                    // - If neither of the references are expired, compare their\n                    //   timestamps. If either of them don't have a timestamp,\n                    //   or the message's timestamp is newer, replace the cache\n                    //   reference with the message reference.\n                    // - If the message reference is older than the cache\n                    //   reference, short-circuit.\n                    if (!isExpired(node) && !isExpired(message) && mTimestamp < cTimestamp) {\n                        return void 0;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the cache is a leaf but the message is a branch, merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(node, message, parent, key, lru), parent, key);\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n        // If the cache and the message are the same value, we branch-merged one\n        // of the message's ancestors. If this is the first time we've seen this\n        // leaf, give the message a $size and $type, attach its graph pointers,\n        // and update the cache sizes and versions.\n\n        if (mType === $error && isFunction(errorSelector)) {\n            message = errorSelector(reconstructPath(requestedPath, key), message);\n        }\n\n        if (mType && node === message) {\n            if (node[__parent] == null) {\n                node = wrapNode(node, cType, node.value);\n                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                node = insertNode(node, parent, key, version);\n            }\n        }\n        // If the cache and message are different, or the message is a\n        // primitive, replace the cache with the message value. If the message\n        // is a sentinel, clone and maintain its type. If the message is a\n        // primitive value, wrap it in an atom.\n        else {\n            var isDistinct = true;\n            // If the cache is a branch, but the message is a leaf, replace the\n            // cache branch with the message leaf.\n            if (cType || !cIsObject) {\n                // Compare the current cache value with the new value. If either of\n                // them don't have a timestamp, or the message's timestamp is newer,\n                // replace the cache value with the message value. If a comparator\n                // is specified, the comparator takes precedence over timestamps.\n                //\n                // Comparing either Number or undefined to undefined always results in false.\n                isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;\n                // If at least one of the cache/message are sentinels, compare them.\n                if ((cType || mType) && isFunction(comparator)) {\n                    isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n                }\n            }\n            if (isDistinct) {\n                message = wrapNode(message, mType, mType ? message.value : message);\n                sizeOffset = getSize(node) - getSize(message);\n                node = replaceNode(node, message, parent, key, lru);\n                parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                node = insertNode(node, parent, key, version);\n            }\n        }\n\n        // Promote the message edge in the LRU.\n        if (isExpired(node)) {\n            expireNode(node, expired, lru);\n        } else {\n            promote(lru, node);\n        }\n    }\n    else if (node == null) {\n        node = insertNode(message, parent, key);\n    }\n\n    return node;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/parent.js":"module.exports = require(\"./../internal/prefix\") + \"parent\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/types/error.js":"module.exports = \"error\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/getSize.js":"var isObject = require(\"./../support/isObject\");\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$size || 0;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/getTimestamp.js":"var isObject = require(\"./../support/isObject\");\nmodule.exports = function getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/isExpired.js":"var now = require(\"./../support/now\");\nvar $now = require(\"../values/expires-now\");\nvar $never = require(\"../values/expires-never\");\n\nmodule.exports = function isExpired(node) {\n    var exp = node.$expires;\n    return (exp != null) && (\n        exp !== $never ) && (\n        exp === $now || exp < now());\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/wrapNode.js":"var jsong = require(\"falcor-json-graph\");\nvar $atom = jsong.atom;\n\nvar now = require(\"./../support/now\");\nvar expiresNow = require(\"../values/expires-now\");\n\nvar __modelCreated = require(\"./../internal/model-created\");\n\nvar atomSize = 50;\n\nvar clone = require(\"./../support/clone\");\nvar isArray = Array.isArray;\nvar getSize = require(\"./../support/getSize\");\nvar getExpires = require(\"./../support/getExpires\");\n\nmodule.exports = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n    } else {\n        node = $atom(value);\n        type = node.$type;\n        node[__modelCreated] = true;\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case \"object\":\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case \"string\":\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === \"number\" && expires < expiresNow) {\n        node.$expires = now() + (expires * -1);\n    }\n\n    node.$size = size;\n\n    return node;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-json-graph/src/index.js":"var pathSyntax = require(\"falcor-path-syntax\");\n\nfunction sentinel(type, value, props) {\n    var copy = Object.create(null);\n    if (props != null) {\n        for(var key in props) {\n            copy[key] = props[key];\n        }\n        \n        copy[\"$type\"] = type;\n        copy.value = value;\n        return copy;\n    }\n    else {\n        return { $type: type, value: value };\n    }    \n}\n\nmodule.exports = {\n    ref: function ref(path, props) {\n        return sentinel(\"ref\", pathSyntax.fromPath(path), props);\n    },\n    atom: function atom(value, props) {\n        return sentinel(\"atom\", value, props);        \n    },\n    undefined: function() {\n        return sentinel(\"atom\");\n    },    \n    error: function error(errorValue, props) {\n        return sentinel(\"error\", errorValue, props);        \n    },\n    pathValue: function pathValue(path, value) {\n        return { path: pathSyntax.fromPath(path), value: value };\n    },\n    pathInvalidation: function pathInvalidation(path) {\n        return { path: pathSyntax.fromPath(path), invalidated: true };\n    }    \n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-syntax/src/index.js":"var Tokenizer = require('./tokenizer');\nvar head = require('./parse-tree/head');\nvar RoutedTokens = require('./RoutedTokens');\n\nvar parser = function parser(string, extendedRules) {\n    return head(new Tokenizer(string, extendedRules));\n};\n\nmodule.exports = parser;\n\n// Constructs the paths from paths / pathValues that have strings.\n// If it does not have a string, just moves the value into the return\n// results.\nparser.fromPathsOrPathValues = function(paths, ext) {\n    if (!paths) {\n        return [];\n    }\n\n    var out = [];\n    for (var i = 0, len = paths.length; i < len; i++) {\n\n        // Is the path a string\n        if (typeof paths[i] === 'string') {\n            out[i] = parser(paths[i], ext);\n        }\n\n        // is the path a path value with a string value.\n        else if (typeof paths[i].path === 'string') {\n            out[i] = {\n                path: parser(paths[i].path, ext), value: paths[i].value\n            };\n        }\n\n        // just copy it over.\n        else {\n            out[i] = paths[i];\n        }\n    }\n\n    return out;\n};\n\n// If the argument is a string, this with convert, else just return\n// the path provided.\nparser.fromPath = function(path, ext) {\n    if (!path) {\n        return [];\n    }\n\n    if (typeof path === 'string') {\n        return parser(path, ext);\n    }\n\n    return path;\n};\n\n// Potential routed tokens.\nparser.RoutedTokens = RoutedTokens;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-syntax/src/tokenizer/index.js":"var TokenTypes = require('./../TokenTypes');\nvar DOT_SEPARATOR = '.';\nvar COMMA_SEPARATOR = ',';\nvar OPENING_BRACKET = '[';\nvar CLOSING_BRACKET = ']';\nvar OPENING_BRACE = '{';\nvar CLOSING_BRACE = '}';\nvar COLON = ':';\nvar ESCAPE = '\\\\';\nvar DOUBLE_OUOTES = '\"';\nvar SINGE_OUOTES = \"'\";\nvar SPACE = \" \";\nvar SPECIAL_CHARACTERS = '\\\\\\'\"[]., ';\nvar EXT_SPECIAL_CHARACTERS = '\\\\{}\\'\"[]., :';\n\nvar Tokenizer = module.exports = function(string, ext) {\n    this._string = string;\n    this._idx = -1;\n    this._extended = ext;\n    this.parseString = '';\n};\n\nTokenizer.prototype = {\n    /**\n     * grabs the next token either from the peek operation or generates the\n     * next token.\n     */\n    next: function() {\n        var nextToken = this._nextToken ?\n            this._nextToken : getNext(this._string, this._idx, this._extended);\n\n        this._idx = nextToken.idx;\n        this._nextToken = false;\n        this.parseString += nextToken.token.token;\n\n        return nextToken.token;\n    },\n\n    /**\n     * will peak but not increment the tokenizer\n     */\n    peek: function() {\n        var nextToken = this._nextToken ?\n            this._nextToken : getNext(this._string, this._idx, this._extended);\n        this._nextToken = nextToken;\n\n        return nextToken.token;\n    }\n};\n\nTokenizer.toNumber = function toNumber(x) {\n    if (!isNaN(+x)) {\n        return +x;\n    }\n    return NaN;\n};\n\nfunction toOutput(token, type, done) {\n    return {\n        token: token,\n        done: done,\n        type: type\n    };\n}\n\nfunction getNext(string, idx, ext) {\n    var output = false;\n    var token = '';\n    var specialChars = ext ?\n        EXT_SPECIAL_CHARACTERS : SPECIAL_CHARACTERS;\n    var done;\n\n    do {\n\n        done = idx + 1 >= string.length;\n        if (done) {\n            break;\n        }\n\n        // we have to peek at the next token\n        var character = string[idx + 1];\n\n        if (character !== undefined &&\n            specialChars.indexOf(character) === -1) {\n\n            token += character;\n            ++idx;\n            continue;\n        }\n\n        // The token to delimiting character transition.\n        else if (token.length) {\n            break;\n        }\n\n        ++idx;\n        var type;\n        switch (character) {\n            case DOT_SEPARATOR:\n                type = TokenTypes.dotSeparator;\n                break;\n            case COMMA_SEPARATOR:\n                type = TokenTypes.commaSeparator;\n                break;\n            case OPENING_BRACKET:\n                type = TokenTypes.openingBracket;\n                break;\n            case CLOSING_BRACKET:\n                type = TokenTypes.closingBracket;\n                break;\n            case OPENING_BRACE:\n                type = TokenTypes.openingBrace;\n                break;\n            case CLOSING_BRACE:\n                type = TokenTypes.closingBrace;\n                break;\n            case SPACE:\n                type = TokenTypes.space;\n                break;\n            case DOUBLE_OUOTES:\n            case SINGE_OUOTES:\n                type = TokenTypes.quote;\n                break;\n            case ESCAPE:\n                type = TokenTypes.escape;\n                break;\n            case COLON:\n                type = TokenTypes.colon;\n                break;\n            default:\n                type = TokenTypes.unknown;\n                break;\n        }\n        output = toOutput(character, type, false);\n        break;\n    } while (!done);\n\n    if (!output && token.length) {\n        output = toOutput(token, TokenTypes.token, false);\n    }\n\n    if (!output) {\n        output = {done: true};\n    }\n\n    return {\n        token: output,\n        idx: idx\n    };\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-syntax/src/TokenTypes.js":"var TokenTypes = {\n    token: 'token',\n    dotSeparator: '.',\n    commaSeparator: ',',\n    openingBracket: '[',\n    closingBracket: ']',\n    openingBrace: '{',\n    closingBrace: '}',\n    escape: '\\\\',\n    space: ' ',\n    colon: ':',\n    quote: 'quote',\n    unknown: 'unknown'\n};\n\nmodule.exports = TokenTypes;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-syntax/src/parse-tree/head.js":"var TokenTypes = require('./../TokenTypes');\nvar E = require('./../exceptions');\nvar indexer = require('./indexer');\n\n/**\n * The top level of the parse tree.  This returns the generated path\n * from the tokenizer.\n */\nmodule.exports = function head(tokenizer) {\n    var token = tokenizer.next();\n    var state = {};\n    var out = [];\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes.token:\n                var first = +token.token[0];\n                if (!isNaN(first)) {\n                    E.throwError(E.invalidIdentifier, tokenizer);\n                }\n                out[out.length] = token.token;\n                break;\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes.dotSeparator:\n                if (out.length === 0) {\n                    E.throwError(E.unexpectedToken, tokenizer);\n                }\n                break;\n\n            // Spaces do nothing.\n            case TokenTypes.space:\n                // NOTE: Spaces at the top level are allowed.\n                // titlesById  .summary is a valid path.\n                break;\n\n\n            // Its time to decend the parse tree.\n            case TokenTypes.openingBracket:\n                indexer(tokenizer, token, state, out);\n                break;\n\n            default:\n                E.throwError(E.unexpectedToken, tokenizer);\n                break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (out.length === 0) {\n        E.throwError(E.invalidPath, tokenizer);\n    }\n\n    return out;\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-syntax/src/exceptions/index.js":"module.exports = {\n    indexer: {\n        nested: 'Indexers cannot be nested.',\n        needQuotes: 'unquoted indexers must be numeric.',\n        empty: 'cannot have empty indexers.',\n        leadingDot: 'Indexers cannot have leading dots.',\n        leadingComma: 'Indexers cannot have leading comma.',\n        requiresComma: 'Indexers require commas between indexer args.',\n        routedTokens: 'Only one token can be used per indexer when specifying routed tokens.'\n    },\n    range: {\n        precedingNaN: 'ranges must be preceded by numbers.',\n        suceedingNaN: 'ranges must be suceeded by numbers.'\n    },\n    routed: {\n        invalid: 'Invalid routed token.  only integers|ranges|keys are supported.'\n    },\n    quote: {\n        empty: 'cannot have empty quoted keys.',\n        illegalEscape: 'Invalid escape character.  Only quotes are escapable.'\n    },\n    unexpectedToken: 'Unexpected token.',\n    invalidIdentifier: 'Invalid Identifier.',\n    invalidPath: 'Please provide a valid path.',\n    throwError: function(err, tokenizer, token) {\n        if (token) {\n            throw err + ' -- ' + tokenizer.parseString + ' with next token: ' + token;\n        }\n        throw err + ' -- ' + tokenizer.parseString;\n    }\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-syntax/src/parse-tree/indexer.js":"var TokenTypes = require('./../TokenTypes');\nvar E = require('./../exceptions');\nvar idxE = E.indexer;\nvar range = require('./range');\nvar quote = require('./quote');\nvar routed = require('./routed');\n\n/**\n * The indexer is all the logic that happens in between\n * the '[', opening bracket, and ']' closing bracket.\n */\nmodule.exports = function indexer(tokenizer, openingToken, state, out) {\n    var token = tokenizer.next();\n    var done = false;\n    var allowedMaxLength = 1;\n    var routedIndexer = false;\n\n    // State variables\n    state.indexer = [];\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes.token:\n            case TokenTypes.quote:\n\n                // ensures that token adders are properly delimited.\n                if (state.indexer.length === allowedMaxLength) {\n                    E.throwError(idxE.requiresComma, tokenizer);\n                }\n                break;\n        }\n\n        switch (token.type) {\n            // Extended syntax case\n            case TokenTypes.openingBrace:\n                routedIndexer = true;\n                routed(tokenizer, token, state, out);\n                break;\n\n\n            case TokenTypes.token:\n                var t = +token.token;\n                if (isNaN(t)) {\n                    E.throwError(idxE.needQuotes, tokenizer);\n                }\n                state.indexer[state.indexer.length] = t;\n                break;\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes.dotSeparator:\n                if (!state.indexer.length) {\n                    E.throwError(idxE.leadingDot, tokenizer);\n                }\n                range(tokenizer, token, state, out);\n                break;\n\n            // Spaces do nothing.\n            case TokenTypes.space:\n                break;\n\n            case TokenTypes.closingBracket:\n                done = true;\n                break;\n\n\n            // The quotes require their own tree due to what can be in it.\n            case TokenTypes.quote:\n                quote(tokenizer, token, state, out);\n                break;\n\n\n            // Its time to decend the parse tree.\n            case TokenTypes.openingBracket:\n                E.throwError(idxE.nested, tokenizer);\n                break;\n\n            case TokenTypes.commaSeparator:\n                ++allowedMaxLength;\n                break;\n\n            default:\n                E.throwError(E.unexpectedToken, tokenizer);\n                break;\n        }\n\n        // If done, leave loop\n        if (done) {\n            break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (state.indexer.length === 0) {\n        E.throwError(idxE.empty, tokenizer);\n    }\n\n    if (state.indexer.length > 1 && routedIndexer) {\n        E.throwError(idxE.routedTokens, tokenizer);\n    }\n\n    // Remember, if an array of 1, keySets will be generated.\n    if (state.indexer.length === 1) {\n        state.indexer = state.indexer[0];\n    }\n\n    out[out.length] = state.indexer;\n\n    // Clean state.\n    state.indexer = undefined;\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-syntax/src/parse-tree/range.js":"var Tokenizer = require('./../tokenizer');\nvar TokenTypes = require('./../TokenTypes');\nvar E = require('./../exceptions');\n\n/**\n * The indexer is all the logic that happens in between\n * the '[', opening bracket, and ']' closing bracket.\n */\nmodule.exports = function range(tokenizer, openingToken, state, out) {\n    var token = tokenizer.peek();\n    var dotCount = 1;\n    var done = false;\n    var inclusive = true;\n\n    // Grab the last token off the stack.  Must be an integer.\n    var idx = state.indexer.length - 1;\n    var from = Tokenizer.toNumber(state.indexer[idx]);\n    var to;\n\n    if (isNaN(from)) {\n        E.throwError(E.range.precedingNaN, tokenizer);\n    }\n\n    // Why is number checking so difficult in javascript.\n\n    while (!done && !token.done) {\n\n        switch (token.type) {\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes.dotSeparator:\n                if (dotCount === 3) {\n                    E.throwError(E.unexpectedToken, tokenizer);\n                }\n                ++dotCount;\n\n                if (dotCount === 3) {\n                    inclusive = false;\n                }\n                break;\n\n            case TokenTypes.token:\n                // move the tokenizer forward and save to.\n                to = Tokenizer.toNumber(tokenizer.next().token);\n\n                // throw potential error.\n                if (isNaN(to)) {\n                    E.throwError(E.range.suceedingNaN, tokenizer);\n                }\n\n                done = true;\n                break;\n\n            default:\n                done = true;\n                break;\n        }\n\n        // Keep cycling through the tokenizer.  But ranges have to peek\n        // before they go to the next token since there is no 'terminating'\n        // character.\n        if (!done) {\n            tokenizer.next();\n\n            // go to the next token without consuming.\n            token = tokenizer.peek();\n        }\n\n        // break and remove state information.\n        else {\n            break;\n        }\n    }\n\n    state.indexer[idx] = {from: from, to: inclusive ? to : to - 1};\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-syntax/src/parse-tree/quote.js":"var TokenTypes = require('./../TokenTypes');\nvar E = require('./../exceptions');\nvar quoteE = E.quote;\n\n/**\n * quote is all the parse tree in between quotes.  This includes the only\n * escaping logic.\n *\n * parse-tree:\n * <opening-quote>(.|(<escape><opening-quote>))*<opening-quote>\n */\nmodule.exports = function quote(tokenizer, openingToken, state, out) {\n    var token = tokenizer.next();\n    var innerToken = '';\n    var openingQuote = openingToken.token;\n    var escaping = false;\n    var done = false;\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes.token:\n            case TokenTypes.space:\n\n            case TokenTypes.dotSeparator:\n            case TokenTypes.commaSeparator:\n\n            case TokenTypes.openingBracket:\n            case TokenTypes.closingBracket:\n            case TokenTypes.openingBrace:\n            case TokenTypes.closingBrace:\n                if (escaping) {\n                    E.throwError(quoteE.illegalEscape, tokenizer);\n                }\n\n                innerToken += token.token;\n                break;\n\n\n            case TokenTypes.quote:\n                // the simple case.  We are escaping\n                if (escaping) {\n                    innerToken += token.token;\n                    escaping = false;\n                }\n\n                // its not a quote that is the opening quote\n                else if (token.token !== openingQuote) {\n                    innerToken += token.token;\n                }\n\n                // last thing left.  Its a quote that is the opening quote\n                // therefore we must produce the inner token of the indexer.\n                else {\n                    done = true;\n                }\n\n                break;\n            case TokenTypes.escape:\n                escaping = true;\n                break;\n\n            default:\n                E.throwError(E.unexpectedToken, tokenizer);\n        }\n\n        // If done, leave loop\n        if (done) {\n            break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (innerToken.length === 0) {\n        E.throwError(quoteE.empty, tokenizer);\n    }\n\n    state.indexer[state.indexer.length] = innerToken;\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-syntax/src/parse-tree/routed.js":"var TokenTypes = require('./../TokenTypes');\nvar RoutedTokens = require('./../RoutedTokens');\nvar E = require('./../exceptions');\nvar routedE = E.routed;\n\n/**\n * The routing logic.\n *\n * parse-tree:\n * <opening-brace><routed-token>(:<token>)<closing-brace>\n */\nmodule.exports = function routed(tokenizer, openingToken, state, out) {\n    var routeToken = tokenizer.next();\n    var named = false;\n    var name = '';\n\n    // ensure the routed token is a valid ident.\n    switch (routeToken.token) {\n        case RoutedTokens.integers:\n        case RoutedTokens.ranges:\n        case RoutedTokens.keys:\n            //valid\n            break;\n        default:\n            E.throwError(routedE.invalid, tokenizer);\n            break;\n    }\n\n    // Now its time for colon or ending brace.\n    var next = tokenizer.next();\n\n    // we are parsing a named identifier.\n    if (next.type === TokenTypes.colon) {\n        named = true;\n\n        // Get the token name.\n        next = tokenizer.next();\n        if (next.type !== TokenTypes.token) {\n            E.throwError(routedE.invalid, tokenizer);\n        }\n        name = next.token;\n\n        // move to the closing brace.\n        next = tokenizer.next();\n    }\n\n    // must close with a brace.\n\n    if (next.type === TokenTypes.closingBrace) {\n        var outputToken = {\n            type: routeToken.token,\n            named: named,\n            name: name\n        };\n        state.indexer[state.indexer.length] = outputToken;\n    }\n\n    // closing brace expected\n    else {\n        E.throwError(routedE.invalid, tokenizer);\n    }\n\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor-path-syntax/src/RoutedTokens.js":"module.exports = {\n    integers: 'integers',\n    ranges: 'ranges',\n    keys: 'keys'\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/model-created.js":"module.exports = \"$modelCreated\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/clone.js":"var prefix = require(\"./../internal/prefix\");\nvar hasOwn = require(\"./../support/hasOwn\");\nvar isArray = Array.isArray;\nvar isObject = require(\"./../support/isObject\");\n\nmodule.exports = function clone(value) {\n    var dest = value;\n    if (isObject(dest)) {\n        dest = isArray(value) ? [] : {};\n        var src = value;\n        for (var key in src) {\n            if (key[0] === prefix || !hasOwn(src, key)) {\n                continue;\n            }\n            dest[key] = src[key];\n        }\n    }\n    return dest;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/getExpires.js":"var isObject = require(\"./isObject\");\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/insertNode.js":"var __key = require(\"./../internal/key\");\nvar __parent = require(\"./../internal/parent\");\nvar __version = require(\"./../internal/version\");\n\nmodule.exports = function insertNode(node, parent, key, version) {\n    node[__key] = key;\n    node[__parent] = parent;\n    node[__version] = version;\n    parent[key] = node;\n    return node;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/replaceNode.js":"var isObject = require(\"./../support/isObject\");\nvar transferBackReferences = require(\"./../support/transferBackReferences\");\nvar removeNodeAndDescendants = require(\"./../support/removeNodeAndDescendants\");\n\nmodule.exports = function replaceNode(node, replacement, parent, key, lru) {\n    if (node === replacement) {\n        return node;\n    } else if (isObject(node)) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru);\n    }\n    parent[key] = replacement;\n    return replacement;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/transferBackReferences.js":"var __ref = require(\"./../internal/ref\");\nvar __context = require(\"./../internal/context\");\nvar __refsLength = require(\"./../internal/refs-length\");\n\nmodule.exports = function transferBackReferences(fromNode, destNode) {\n    var fromNodeRefsLength = fromNode[__refsLength] || 0,\n        destNodeRefsLength = destNode[__refsLength] || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[__ref + i];\n        if (ref !== void 0) {\n            ref[__context] = destNode;\n            destNode[__ref + (destNodeRefsLength + i)] = ref;\n            fromNode[__ref + i] = void 0;\n        }\n    }\n    destNode[__refsLength] = fromNodeRefsLength + destNodeRefsLength;\n    fromNode[__refsLength] = void 0;\n    return destNode;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/removeNodeAndDescendants.js":"var hasOwn = require(\"./../support/hasOwn\");\nvar prefix = require(\"./../internal/prefix\");\nvar removeNode = require(\"./../support/removeNode\");\n\nmodule.exports = function removeNodeAndDescendants(node, parent, key, lru) {\n    if (removeNode(node, parent, key, lru)) {\n        if (node.$type == null) {\n            for (var key2 in node) {\n                if (key2[0] !== prefix && key2[0] !== \"$\" && hasOwn(node, key2)) {\n                    removeNodeAndDescendants(node[key2], node, key2, lru);\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/removeNode.js":"var $ref = require(\"./../types/ref\");\nvar __parent = require(\"./../internal/parent\");\nvar splice = require(\"./../lru/splice\");\nvar isObject = require(\"./../support/isObject\");\nvar unlinkBackReferences = require(\"./../support/unlinkBackReferences\");\nvar unlinkForwardReference = require(\"./../support/unlinkForwardReference\");\n\nmodule.exports = function removeNode(node, parent, key, lru) {\n    if (isObject(node)) {\n        var type = node.$type;\n        if (Boolean(type)) {\n            if (type === $ref) {\n                unlinkForwardReference(node);\n            }\n            splice(lru, node);\n        }\n        unlinkBackReferences(node);\n        parent[key] = node[__parent] = void 0;\n        return true;\n    }\n    return false;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/unlinkBackReferences.js":"var __ref = require(\"./../internal/ref\");\nvar __context = require(\"./../internal/context\");\nvar __refIndex = require(\"./../internal/ref-index\");\nvar __refsLength = require(\"./../internal/refs-length\");\n\nmodule.exports = function unlinkBackReferences(node) {\n    var i = -1, n = node[__refsLength] || 0;\n    while (++i < n) {\n        var ref = node[__ref + i];\n        if (ref != null) {\n            ref[__context] = ref[__refIndex] = node[__ref + i] = void 0;\n        }\n    }\n    node[__refsLength] = void 0;\n    return node;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/unlinkForwardReference.js":"var __ref = require(\"./../internal/ref\");\nvar __context = require(\"./../internal/context\");\nvar __refIndex = require(\"./../internal/ref-index\");\nvar __refsLength = require(\"./../internal/refs-length\");\n\nmodule.exports = function unlinkForwardReference(reference) {\n    var destination = reference[__context];\n    if (destination) {\n        var i = (reference[__refIndex] || 0) - 1,\n            n = (destination[__refsLength] || 0) - 1;\n        while (++i <= n) {\n            destination[__ref + i] = destination[__ref + (i + 1)];\n        }\n        destination[__refsLength] = n;\n        reference[__refIndex] = reference[__context] = destination = void 0;\n    }\n    return reference;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/updateNodeAncestors.js":"var __key = require(\"./../internal/key\");\nvar __version = require(\"./../internal/version\");\nvar __parent = require(\"./../internal/parent\");\nvar removeNode = require(\"./../support/removeNode\");\nvar updateBackReferenceVersions = require(\"./../support/updateBackReferenceVersions\");\n\nmodule.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {\n    var child = nodeArg;\n    do {\n        var node = child[__parent];\n        var size = child.$size = (child.$size || 0) - offset;\n        if (size <= 0 && node != null) {\n            removeNode(child, node, child[__key], lru);\n        } else if (child[__version] !== version) {\n            updateBackReferenceVersions(child, version);\n        }\n        child = node;\n    } while (child);\n    return nodeArg;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/updateBackReferenceVersions.js":"var __ref = require(\"./../internal/ref\");\nvar __parent = require(\"./../internal/parent\");\nvar __version = require(\"./../internal/version\");\nvar __refsLength = require(\"./../internal/refs-length\");\n\nmodule.exports = function updateBackReferenceVersions(nodeArg, version) {\n    var stack = [nodeArg];\n    var count = 0;\n    do {\n        var node = stack[count--];\n        if (node && node[__version] !== version) {\n            node[__version] = version;\n            stack[count++] = node[__parent];\n            var i = -1;\n            var n = node[__refsLength] || 0;\n            while (++i < n) {\n                stack[count++] = node[__ref + i];\n            }\n        }\n    } while (count > -1);\n    return nodeArg;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/reconstructPath.js":"/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = function reconstructPath(currentPath, key) {\n\n    var path = currentPath.slice(0, currentPath.depth);\n    path[path.length] = key;\n\n    return path;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/set/setPathValues.js":"var __key = require(\"./../internal/key\");\nvar __ref = require(\"./../internal/ref\");\nvar __parent = require(\"./../internal/parent\");\nvar __context = require(\"./../internal/context\");\nvar __version = require(\"./../internal/version\");\nvar __refIndex = require(\"./../internal/ref-index\");\nvar __refsLength = require(\"./../internal/refs-length\");\n\nvar $ref = require(\"./../types/ref\");\n\nvar getBoundValue = require(\"./../get/getBoundValue\");\n\nvar promote = require(\"./../lru/promote\");\nvar isExpired = require(\"./../support/isExpired\");\nvar isFunction = require(\"./../support/isFunction\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar expireNode = require(\"./../support/expireNode\");\nvar iterateKeySet = require(\"falcor-path-utils\").iterateKeySet;\nvar incrementVersion = require(\"./../support/incrementVersion\");\nvar mergeValueOrInsertBranch = require(\"./../support/mergeValueOrInsertBranch\");\n\n/**\n * Sets a list of PathValues into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} pathValues - the PathValues to set.\n * @return {Array.<Path>} - a list of optimized paths for the successfully set values.\n */\n\nmodule.exports = function setPathValues(model, pathValues, x, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = bound.length ? getBoundValue(model, bound).value : cache;\n    var parent = node[__parent] || cache;\n    var initialVersion = cache[__version];\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(\n            value, path, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    var newVersion = cache[__version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(\n    value, path, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(\n            root, parent, node, key, value,\n            branch, false, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n        optimizedPath[optimizedPath.index++] = key;\n        var nextNode = results[0];\n        var nextParent = results[1];\n        if (nextNode) {\n            if (branch) {\n                setPathSet(\n                    value, path, depth + 1,\n                    root, nextParent, nextNode,\n                    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                    version, expired, lru, comparator, errorSelector\n                );\n            } else {\n                promote(lru, nextNode);\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var reference = node.value;\n    optimizedPath.splice(0, optimizedPath.length);\n    optimizedPath.push.apply(optimizedPath, reference);\n\n    if (isExpired(node)) {\n        optimizedPath.index = reference.length;\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    promote(lru, node);\n\n    var container = node;\n    var parent = root;\n\n    node = node[__context];\n\n    if (node != null) {\n        parent = node[__parent] || root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = setNode(\n                root, parent, node, key, value,\n                branch, true, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n            node = results[0];\n            if (isPrimitive(node)) {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container[__context] !== node) {\n            var backRefs = node[__refsLength] || 0;\n            node[__refsLength] = backRefs + 1;\n            node[__ref + backRefs] = container;\n            container[__context] = node;\n            container[__refIndex] = backRefs;\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node[__key];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    node = mergeValueOrInsertBranch(\n        parent, node, key, value,\n        branch, reference, requestedPath, optimizedPath,\n        version, expired, lru, comparator, errorSelector\n    );\n\n    return [node, parent];\n}\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/getBoundValue.js":"var getValueSync = require(\"./../get/getValueSync\");\nvar InvalidModelError = require(\"./../errors/InvalidModelError\");\n\nmodule.exports = function getBoundValue(model, pathArg, materialized) {\n\n    var path = pathArg;\n    var boundPath = pathArg;\n    var boxed, treatErrorsAsValues,\n        value, shorted, found;\n\n    boxed = model._boxed;\n    materialized = model._materialized;\n    treatErrorsAsValues = model._treatErrorsAsValues;\n\n    model._boxed = true;\n    model._materialized = materialized === undefined || materialized;\n    model._treatErrorsAsValues = true;\n\n    value = getValueSync(model, path.concat(null), true);\n\n    model._boxed = boxed;\n    model._materialized = materialized;\n    model._treatErrorsAsValues = treatErrorsAsValues;\n\n    path = value.optimizedPath;\n    shorted = value.shorted;\n    found = value.found;\n    value = value.value;\n\n    while (path.length && path[path.length - 1] === null) {\n        path.pop();\n    }\n\n    if (found && shorted) {\n        throw new InvalidModelError(boundPath, path);\n    }\n\n    return {\n        path: path,\n        value: value,\n        shorted: shorted,\n        found: found\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/getValueSync.js":"var followReference = require(\"./../get/followReference\");\nvar clone = require(\"./../get/util/clone\");\nvar isExpired = require(\"./../get/util/isExpired\");\nvar promote = require(\"./../get/util/lru\").promote;\nvar $ref = require(\"./../types/ref\");\nvar $atom = require(\"./../types/atom\");\nvar $error = require(\"./../types/error\");\n\nmodule.exports = function getValueSync(model, simplePath, noClone) {\n    var root = model._root.cache;\n    var len = simplePath.length;\n    var optimizedPath = [];\n    var shorted = false, shouldShort = false;\n    var depth = 0;\n    var key, i, next = root, curr = root, out = root, type, ref, refNode;\n    var found = true;\n    var expired = false;\n\n    while (next && depth < len) {\n        key = simplePath[depth++];\n        if (key !== null) {\n            next = curr[key];\n            optimizedPath[optimizedPath.length] = key;\n        }\n\n        if (!next) {\n            out = undefined;\n            shorted = true;\n            found = false;\n            break;\n        }\n\n        type = next.$type;\n\n        // A materialized item.  There is nothing to deref to.\n        if (type === $atom && next.value === undefined) {\n            out = undefined;\n            found = false;\n            shorted = depth < len;\n            break;\n        }\n\n        // Up to the last key we follow references, ensure that they are not\n        // expired either.\n        if (depth < len) {\n            if (type === $ref) {\n\n                // If the reference is expired then we need to set expired to\n                // true.\n                if (isExpired(next)) {\n                    expired = true;\n                    out = undefined;\n                    found = false;\n                    break;\n                }\n\n                ref = followReference(model, root, root, next, next.value);\n                refNode = ref[0];\n\n                // The next node is also set to undefined because nothing\n                // could be found, this reference points to nothing, so\n                // nothing must be returned.\n                if (!refNode) {\n                    out = void 0;\n                    next = void 0;\n                    found = false;\n                    break;\n                }\n                type = refNode.$type;\n                next = refNode;\n                optimizedPath = ref[1].slice(0);\n            }\n\n            if (type) {\n                break;\n            }\n        }\n        // If there is a value, then we have great success, else, report an undefined.\n        else {\n            out = next;\n        }\n        curr = next;\n    }\n\n    if (depth < len && !expired) {\n        // Unfortunately, if all that follows are nulls, then we have not shorted.\n        for (i = depth; i < len; ++i) {\n            if (simplePath[depth] !== null) {\n                shouldShort = true;\n                break;\n            }\n        }\n        // if we should short or report value.  Values are reported on nulls.\n        if (shouldShort) {\n            shorted = true;\n            out = void 0;\n        } else {\n            out = next;\n        }\n\n        for (i = depth; i < len; ++i) {\n            if (simplePath[i] !== null) {\n                optimizedPath[optimizedPath.length] = simplePath[i];\n            }\n        }\n    }\n\n    // promotes if not expired\n    if (out && type) {\n        if (isExpired(out)) {\n            out = void 0;\n        } else {\n            promote(model, out);\n        }\n    }\n\n    // if (out && out.$type === $error && !model._treatErrorsAsValues) {\n    if (out && type === $error && !model._treatErrorsAsValues) {\n        throw {\n            path: depth === len ? simplePath : simplePath.slice(0, depth),\n            value: out.value\n        };\n    } else if (out && model._boxed) {\n        out = Boolean(type) && !noClone ? clone(out) : out;\n    } else if (!out && model._materialized) {\n        out = {$type: $atom};\n    } else if (out) {\n        out = out.value;\n    }\n\n    return {\n        value: out,\n        shorted: shorted,\n        optimizedPath: optimizedPath,\n        found: found\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/followReference.js":"var hardLink = require(\"./../get/util/hardlink\");\nvar createHardlink = hardLink.create;\nvar onValue = require(\"./../get/onValue\");\nvar isExpired = require(\"./../get/util/isExpired\");\nvar $ref = require(\"./../types/ref\");\nvar __context = require(\"./../internal/context\");\nvar promote = require(\"./../get/util/lru\").promote;\n\n/* eslint-disable no-constant-condition */\nfunction followReference(model, root, nodeArg, referenceContainerArg,\n                         referenceArg, seed, isJSONG) {\n\n    var node = nodeArg;\n    var reference = referenceArg;\n    var referenceContainer = referenceContainerArg;\n    var depth = 0;\n    var k, next;\n\n    while (true) {\n        if (depth === 0 && referenceContainer[__context]) {\n            depth = reference.length;\n            next = referenceContainer[__context];\n        } else {\n            k = reference[depth++];\n            next = node[k];\n        }\n        if (next) {\n            var type = next.$type;\n            var value = type && next.value || next;\n\n            if (depth < reference.length) {\n                if (type) {\n                    node = next;\n                    break;\n                }\n\n                node = next;\n                continue;\n            }\n\n            // We need to report a value or follow another reference.\n            else {\n\n                node = next;\n\n                if (type && isExpired(next)) {\n                    break;\n                }\n\n                if (!referenceContainer[__context]) {\n                    createHardlink(referenceContainer, next);\n                }\n\n                // Restart the reference follower.\n                if (type === $ref) {\n                    if (isJSONG) {\n                        onValue(model, next, seed, null, null, null,\n                                reference, reference.length, isJSONG);\n                    } else {\n                        promote(model, next);\n                    }\n\n                    depth = 0;\n                    reference = value;\n                    referenceContainer = next;\n                    node = root;\n                    continue;\n                }\n\n                break;\n            }\n        } else {\n            node = void 0;\n        }\n        break;\n    }\n\n\n    if (depth < reference.length && node !== void 0) {\n        var ref = [];\n        for (var i = 0; i < depth; i++) {\n            ref[i] = reference[i];\n        }\n        reference = ref;\n    }\n\n    return [node, reference];\n}\n/* eslint-enable */\n\nmodule.exports = followReference;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/util/hardlink.js":"var __ref = require(\"./../../internal/ref\");\nvar __context = require(\"./../../internal/context\");\nvar __refIndex = require(\"./../../internal/ref-index\");\nvar __refsLength = require(\"./../../internal/refs-length\");\n\nfunction createHardlink(from, to) {\n\n    // create a back reference\n    var backRefs = to[__refsLength] || 0;\n    to[__ref + backRefs] = from;\n    to[__refsLength] = backRefs + 1;\n\n    // create a hard reference\n    from[__refIndex] = backRefs;\n    from[__context] = to;\n}\n\nfunction removeHardlink(cacheObject) {\n    var context = cacheObject[__context];\n    if (context) {\n        var idx = cacheObject[__refIndex];\n        var len = context[__refsLength];\n\n        while (idx < len) {\n            context[__ref + idx] = context[__ref + idx + 1];\n            ++idx;\n        }\n\n        context[__refsLength] = len - 1;\n        cacheObject[__context] = void 0;\n        cacheObject[__refIndex] = void 0;\n    }\n}\n\nmodule.exports = {\n    create: createHardlink,\n    remove: removeHardlink\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/onValue.js":"var lru = require(\"./util/lru\");\nvar clone = require(\"./util/clone\");\nvar promote = lru.promote;\nvar $ref = require(\"./../types/ref\");\nvar $atom = require(\"./../types/atom\");\nvar $error = require(\"./../types/error\");\nvar $modelCreated = require(\"./../internal/model-created\");\n\nmodule.exports = function onValue(model, node, seed, depth, outerResults,\n                                  requestedPath, optimizedPath, optimizedLength,\n                                  isJSONG, fromReference) {\n    // Preload\n    if (!seed) {\n        return;\n    }\n\n    var i, len, k, key, curr, prev, prevK;\n    var materialized = false, valueNode;\n\n    if (node) {\n        promote(model, node);\n    }\n\n    if (!node || node.value === undefined) {\n        materialized = model._materialized;\n    }\n\n    // materialized\n    if (materialized) {\n        valueNode = {$type: $atom};\n    }\n\n    // Boxed Mode will clone the node.\n    else if (model._boxed) {\n        valueNode = clone(node);\n    }\n\n    // JSONG always clones the node.\n    else if (node.$type === $ref || node.$type === $error) {\n        if (isJSONG) {\n            valueNode = clone(node);\n        } else {\n            valueNode = node.value;\n        }\n    }\n\n    else if (isJSONG) {\n        var isObject = node.value && typeof node.value === \"object\";\n        var isUserCreatedNode = !node[$modelCreated];\n        if (isObject || isUserCreatedNode) {\n            valueNode = clone(node);\n        } else {\n            valueNode = node.value;\n        }\n    }\n\n    else {\n        valueNode = node.value;\n    }\n\n    if (outerResults) {\n        outerResults.hasValue = true;\n    }\n\n    if (isJSONG) {\n        curr = seed.jsonGraph;\n        if (!curr) {\n            curr = seed.jsonGraph = {};\n            seed.paths = [];\n        }\n        for (i = 0, len = optimizedLength - 1; i < len; i++) {\n            key = optimizedPath[i];\n\n            if (!curr[key]) {\n                curr[key] = {};\n            }\n            curr = curr[key];\n        }\n\n        // assign the last\n        key = optimizedPath[i];\n\n        // TODO: Special case? do string comparisons make big difference?\n        curr[key] = materialized ? {$type: $atom} : valueNode;\n        if (requestedPath) {\n            seed.paths.push(requestedPath.slice(0, depth));\n        }\n    }\n\n    // The output is pathMap and the depth is 0.  It is just a\n    // value report it as the found JSON\n    else if (depth === 0) {\n        seed.json = valueNode;\n    }\n\n    // The output is pathMap but we need to build the pathMap before\n    // reporting the value.\n    else {\n        curr = seed.json;\n        if (!curr) {\n            curr = seed.json = {};\n        }\n        for (i = 0; i < depth - 1; i++) {\n            k = requestedPath[i];\n            if (!curr[k]) {\n                curr[k] = {};\n            }\n            prev = curr;\n            prevK = k;\n            curr = curr[k];\n        }\n        k = requestedPath[i];\n        if (k !== null) {\n            curr[k] = valueNode;\n        } else {\n            prev[prevK] = valueNode;\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/util/lru.js":"var __head = require(\"./../../internal/head\");\nvar __tail = require(\"./../../internal/tail\");\nvar __next = require(\"./../../internal/next\");\nvar __prev = require(\"./../../internal/prev\");\nvar __invalidated = require(\"./../../internal/invalidated\");\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nfunction lruPromote(model, object) {\n    var root = model._root;\n    var head = root[__head];\n    if (head === object) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    var prev = object[__prev];\n    var next = object[__next];\n    if (next) {\n        next[__prev] = prev;\n    }\n    if (prev) {\n        prev[__next] = next;\n    }\n    object[__prev] = void 0;\n\n    // Insert into head position\n    root[__head] = object;\n    object[__next] = head;\n    head[__prev] = object;\n}\n\nfunction lruSplice(model, object) {\n    var root = model._root;\n\n    // Its in the cache.  Splice out.\n    var prev = object[__prev];\n    var next = object[__next];\n    if (next) {\n        next[__prev] = prev;\n    }\n    if (prev) {\n        prev[__next] = next;\n    }\n    object[__prev] = void 0;\n\n    if (object === root[__head]) {\n        root[__head] = void 0;\n    }\n    if (object === root[__tail]) {\n        root[__tail] = void 0;\n    }\n    object[__invalidated] = true;\n    root.expired.push(object);\n}\n\nmodule.exports = {\n    promote: lruPromote,\n    splice: lruSplice\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/util/clone.js":"// Copies the node\nvar prefix = require(\"./../../internal/prefix\");\n\nmodule.exports = function clone(node) {\n    var outValue, i, len;\n    var keys = Object.keys(node);\n    outValue = {};\n    for (i = 0, len = keys.length; i < len; i++) {\n        var k = keys[i];\n        if (k[0] === prefix) {\n            continue;\n        }\n        outValue[k] = node[k];\n    }\n    return outValue;\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/types/atom.js":"module.exports = \"atom\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/util/isExpired.js":"var now = require(\"./../../support/now\");\nmodule.exports = function isExpired(node) {\n    var $expires = node.$expires === void 0 && -1 || node.$expires;\n    return $expires !== -1 && $expires !== 1 && ($expires === 0 || $expires < now());\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/errors/InvalidModelError.js":"var NAME = \"InvalidModelError\";\nvar MESSAGE = \"The boundPath of the model is not valid since a value or error was found before the path end.\";\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {String} message\n * @private\n */\nfunction InvalidModelError(boundPath, shortedPath) {\n    this.message = MESSAGE;\n    this.stack = (new Error()).stack;\n    this.boundPath = boundPath;\n    this.shortedPath = shortedPath;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nInvalidModelError.prototype = new Error();\nInvalidModelError.prototype.name = NAME;\nInvalidModelError.message = MESSAGE;\n\nmodule.exports = InvalidModelError;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/mergeValueOrInsertBranch.js":"var $ref = require(\"./../types/ref\");\nvar $error = require(\"./../types/error\");\nvar getType = require(\"./../support/getType\");\nvar getSize = require(\"./../support/getSize\");\nvar getTimestamp = require(\"./../support/getTimestamp\");\n\nvar isExpired = require(\"./../support/isExpired\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar isFunction = require(\"./../support/isFunction\");\n\nvar wrapNode = require(\"./../support/wrapNode\");\nvar expireNode = require(\"./../support/expireNode\");\nvar insertNode = require(\"./../support/insertNode\");\nvar replaceNode = require(\"./../support/replaceNode\");\nvar updateNodeAncestors = require(\"./../support/updateNodeAncestors\");\nvar updateBackReferenceVersions = require(\"./../support/updateBackReferenceVersions\");\nvar reconstructPath = require(\"./../support/reconstructPath\");\n\nmodule.exports = function mergeValueOrInsertBranch(\n    parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = getType(node, reference);\n\n    if (branch || reference) {\n        if (type && isExpired(node)) {\n            type = \"expired\";\n            expireNode(node, expired, lru);\n        }\n        if ((type && type !== $ref) || isPrimitive(node)) {\n            node = replaceNode(node, {}, parent, key, lru);\n            node = insertNode(node, parent, key, version);\n            node = updateBackReferenceVersions(node, version);\n        }\n    } else {\n        var message = value;\n        var mType = getType(message);\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        //\n        // Comparing either Number or undefined to undefined always results in false.\n        var isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;\n        // If at least one of the cache/message are sentinels, compare them.\n        if ((type || mType) && isFunction(comparator)) {\n            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n        }\n        if (isDistinct) {\n\n            if (mType === $error && isFunction(errorSelector)) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n            }\n\n            message = wrapNode(message, mType, mType ? message.value : message);\n\n            var sizeOffset = getSize(node) - getSize(message);\n\n            node = replaceNode(node, message, parent, key, lru);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version);\n        }\n    }\n\n    return node;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/getType.js":"var isObject = require(\"./../support/isObject\");\n\nmodule.exports = function getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return \"branch\";\n    }\n    return type;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/request/RequestQueueV2.js":"var RequestTypes = require(\"./RequestTypes\");\nvar GetRequest = require(\"./GetRequestV2\");\n\n/**\n * The request queue is responsible for queuing the operations to\n * the model\"s dataSource.\n *\n * @param {Model} model -\n * @param {Scheduler} scheduler -\n */\nfunction RequestQueueV2(model, scheduler) {\n    this.model = model;\n    this.scheduler = scheduler;\n    this.requests = this._requests = [];\n}\n\nRequestQueueV2.prototype = {\n    /**\n     * Sets the scheduler, but will not affect any current requests.\n     */\n    setScheduler: function(scheduler) {\n        this.scheduler = scheduler;\n    },\n\n    /**\n     * Creates a get request to the dataSource.  Depending on the current\n     * scheduler is how the getRequest will be flushed.\n     * @param {Array} requestedPaths -\n     * @param {Array} optimizedPaths -\n     * @param {Function} cb -\n     */\n    get: function(requestedPaths, optimizedPaths, cb) {\n        var self = this;\n        var disposables = [];\n        var count = 0;\n        var requests = self._requests;\n        var i, len;\n        var oRemainingPaths = optimizedPaths;\n        var rRemainingPaths = requestedPaths;\n        var disposed = false;\n        var request;\n\n        for (i = 0, len = requests.length; i < len; ++i) {\n            request = requests[i];\n            if (request.type !== RequestTypes.GetRequest) {\n                continue;\n            }\n\n            // The request has been sent, attempt to jump on the request\n            // if possible.\n            if (request.sent) {\n                var results = request.add(\n                    rRemainingPaths, oRemainingPaths, refCountCallback);\n\n                // Checks to see if the results were successfully inserted\n                // into the outgoing results.  Then our paths will be reduced\n                // to the complement.\n                if (results[0]) {\n                    rRemainingPaths = results[1];\n                    oRemainingPaths = results[2];\n                    disposables[disposables.length] = results[3];\n                    ++count;\n                }\n            }\n\n            // If there is a non sent request, then we can batch and leave.\n            else {\n                request.batch(\n                    rRemainingPaths, oRemainingPaths, refCountCallback);\n                oRemainingPaths = [];\n                rRemainingPaths = [];\n                ++count;\n            }\n\n            // If there are no more remaining paths then exit the loop.\n            if (!oRemainingPaths.length) {\n                break;\n            }\n        }\n\n        // After going through all the available requests if there are more\n        // paths to process then a new request must be made.\n        if (oRemainingPaths.length) {\n            request = new GetRequest(self.scheduler, self);\n            requests[requests.length] = request;\n            ++count;\n            var disposable = request.batch(\n                rRemainingPaths, oRemainingPaths, refCountCallback);\n            disposables[disposables.length] = disposable;\n        }\n\n        // This is a simple refCount callback.\n        function refCountCallback() {\n            if (disposed) {\n                return;\n            }\n\n            --count;\n\n            // If the count becomes 0, then its time to notify the\n            // listener that the request is done.\n            if (count === 0) {\n                cb();\n            }\n        }\n\n        // When disposing the request all of the outbound requests will be\n        // disposed of.\n        return function() {\n            if (disposed || count === 0) {\n                return;\n            }\n\n            disposed = true;\n            var length = disposables.length;\n            for (var idx = 0; idx < length; ++idx) {\n                disposables[idx]();\n            }\n        };\n    },\n\n    /**\n     * Removes the request from the request\n     */\n    removeRequest: function(request) {\n        var requests = this._requests;\n        var i = requests.length;\n        while (--i >= 0) {\n            if (requests[i].id === request.id) {\n                requests.splice(i, 1);\n                break;\n            }\n        }\n    }\n};\n\nmodule.exports = RequestQueueV2;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/request/RequestTypes.js":"module.exports = {\n    GetRequest: \"GET\"\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/request/GetRequestV2.js":"var complement = require(\"./complement\");\nvar flushGetRequest = require(\"./flushGetRequest\");\nvar REQUEST_ID = 0;\nvar GetRequestType = require(\"./RequestTypes\").GetRequest;\nvar setJSONGraphs = require(\"./../set/setJSONGraphs\");\nvar setPathValues = require(\"./../set/setPathValues\");\nvar $error = require(\"./../types/error\");\nvar emptyArray = [];\n\n/**\n * Creates a new GetRequest.  This GetRequest takes a scheduler and\n * the request queue.  Once the scheduler fires, all batched requests\n * will be sent to the server.  Upon request completion, the data is\n * merged back into the cache and all callbacks are notified.\n *\n * @param {Scheduler} scheduler -\n * @param {RequestQueueV2} requestQueue -\n */\nvar GetRequestV2 = function(scheduler, requestQueue) {\n    this.sent = false;\n    this.scheduled = false;\n    this.requestQueue = requestQueue;\n    this.id = ++REQUEST_ID;\n    this.type = GetRequestType;\n\n    this._scheduler = scheduler;\n    this._pathMap = {};\n    this._optimizedPaths = [];\n    this._requestedPaths = [];\n    this._callbacks = [];\n    this._count = 0;\n    this._disposable = null;\n    this._collapsed = null;\n    this._disposed = false;\n};\n\nGetRequestV2.prototype = {\n    /**\n     * batches the paths that are passed in.  Once the request is complete,\n     * all callbacks will be called and the request will be removed from\n     * parent queue.\n     * @param {Array} requestedPaths -\n     * @param {Array} optimizedPaths -\n     * @param {Function} callback -\n     */\n    batch: function(requestedPaths, optimizedPaths, callback) {\n        var self = this;\n        var oPaths = self._optimizedPaths;\n        var rPaths = self._requestedPaths;\n        var callbacks = self._callbacks;\n        var idx = oPaths.length;\n\n        // If its not sent, simply add it to the requested paths\n        // and callbacks.\n        oPaths[idx] = optimizedPaths;\n        rPaths[idx] = requestedPaths;\n        callbacks[idx] = callback;\n        ++self._count;\n\n        // If it has not been scheduled, then schedule the action\n        if (!self.scheduled) {\n            self.scheduled = true;\n\n            self._disposable = self._scheduler.schedule(function() {\n                flushGetRequest(self, oPaths, function(err, data) {\n                    self.requestQueue.removeRequest(self);\n                    self._disposed = true;\n\n                    // If there is at least one callback remaining, then\n                    // callback the callbacks.\n                    if (self._count) {\n                        self._merge(rPaths, err, data);\n\n                        // Call the callbacks.  The first one inserts all the\n                        // data so that the rest do not have consider if their\n                        // data is present or not.\n                        for (var i = 0, len = callbacks.length; i < len; ++i) {\n                            var fn = callbacks[i];\n                            if (fn) {\n                                fn(err, data);\n                            }\n                        }\n                    }\n                });\n            });\n        }\n\n        // Disposes this batched request.  This does not mean that the\n        // entire request has been disposed, but just the local one, if all\n        // requests are disposed, then the outer disposable will be removed.\n        return createDisposable(self, idx);\n    },\n\n    /**\n     * Attempts to add paths to the outgoing request.  If there are added\n     * paths then the request callback will be added to the callback list.\n     *\n     * @returns {Array} - the remaining paths in the request.\n     */\n    add: function(requested, optimized, callback) {\n        // uses the length tree complement calculator.\n        var self = this;\n        var complementTuple = complement(requested, optimized, self._pathMap);\n        var optimizedComplement;\n        var requestedComplement;\n\n        if (complementTuple) {\n            requestedComplement = complementTuple[2];\n            optimizedComplement = complementTuple[1];\n        } else {\n            requestedComplement = requested;\n            optimizedComplement = optimized;\n        }\n\n        var inserted = false;\n        var disposable = false;\n\n        // If the out paths is less than the passed in paths, then there\n        // has been an intersection and the complement has been returned.\n        // Therefore, this can be deduped across requests.\n        if (optimizedComplement.length < optimized.length) {\n            inserted = true;\n            var idx = self._callbacks.length;\n            self._callbacks[idx] = callback;\n            self._requestedPaths[idx] = complementTuple[0];\n            self._optimizedPaths[idx] = [];\n            ++self._count;\n\n            disposable = createDisposable(self, idx);\n        }\n\n        return [inserted, requestedComplement, optimizedComplement, disposable];\n    },\n\n    /**\n     * merges the response into the model\"s cache.\n     */\n    _merge: function(requested, err, data) {\n        var self = this;\n        var model = self.requestQueue.model;\n        var modelRoot = model._root;\n        var errorSelector = modelRoot.errorSelector;\n        var comparator = modelRoot.comparator;\n        var boundPath = model._path;\n\n        model._path = emptyArray;\n\n        // flatten all the requested paths, adds them to the\n        var nextPaths = flattenRequestedPaths(requested);\n\n        // Insert errors in every requested position.\n        if (err) {\n            var error = err;\n\n            // Converts errors to objects, a more friendly storage\n            // of errors.\n            if (error instanceof Error) {\n                error = {\n                    message: error.message\n                };\n            }\n\n            // Not all errors are value $types.\n            if (!error.$type) {\n                error = {\n                    $type: $error,\n                    value: error\n                };\n            }\n\n            var pathValues = nextPaths.map(function(x) {\n                return {\n                    path: x,\n                    value: error\n                };\n            });\n            setPathValues(model, pathValues, null, errorSelector, comparator);\n        }\n\n        // Insert the jsonGraph from the dataSource.\n        else {\n            setJSONGraphs(model, [{\n                paths: nextPaths,\n                jsonGraph: data.jsonGraph\n            }], null, errorSelector, comparator);\n        }\n\n        // return the model\"s boundPath\n        model._path = boundPath;\n    }\n};\n\n// Creates a more efficient closure of the things that are\n// needed.  So the request and the idx.  Also prevents code\n// duplication.\nfunction createDisposable(request, idx) {\n    var disposed = false;\n    return function() {\n        if (disposed || request._disposed) {\n            return;\n        }\n\n        disposed = true;\n        request._callbacks[idx] = null;\n        request._optimizedPaths[idx] = [];\n        request._requestedPaths[idx] = [];\n\n        // If there are no more requests, then dispose all of the request.\n        var count = --request._count;\n        if (count === 0 && !request.sent) {\n            request._disposable.dispose();\n            request.requestQueue.removeRequest(request);\n        }\n    };\n}\n\nfunction flattenRequestedPaths(requested) {\n    var out = [];\n    var outLen = -1;\n    for (var i = 0, len = requested.length; i < len; ++i) {\n        var paths = requested[i];\n        for (var j = 0, innerLen = paths.length; j < innerLen; ++j) {\n            out[++outLen] = paths[j];\n        }\n    }\n    return out;\n}\n\nmodule.exports = GetRequestV2;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/request/complement.js":"var hasIntersection = require(\"falcor-path-utils\").hasIntersection;\nvar arraySlice = require(\"./../support/array-slice\");\n\n/**\n * creates the complement of the requested and optimized paths\n * based on the provided tree.\n *\n * If there is no complement then this is just a glorified\n * array copy.\n */\nmodule.exports = function complement(requested, optimized, tree) {\n    var optimizedComplement = [];\n    var requestedComplement = [];\n    var requestedIntersection = [];\n    var intersectionLength = -1, complementLength = -1;\n    var intersectionFound = false;\n\n    for (var i = 0, len = optimized.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        var path = optimized[i];\n        var subTree = tree[path.length];\n\n        // If there is no subtree to look into or there is no intersection.\n        if (!subTree || !hasIntersection(subTree, path, 0)) {\n\n            if (intersectionFound) {\n                optimizedComplement[++complementLength] = path;\n                requestedComplement[complementLength] = requested[i];\n            }\n        } else {\n            // If there has been no intersection yet and\n            // i is bigger than 0 (meaning we have had only complements)\n            // then we need to update our complements to match the current\n            // reality.\n            if (!intersectionFound && i > 0) {\n                requestedComplement = arraySlice(requested, 0, i);\n                optimizedComplement = arraySlice(optimized, 0, i);\n            }\n\n            requestedIntersection[++intersectionLength] = requested[i];\n            intersectionFound = true;\n        }\n    }\n\n    if (!intersectionFound) {\n        return null;\n    }\n\n    return [requestedIntersection, optimizedComplement, requestedComplement ];\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/array-slice.js":"module.exports = function arraySlice(array, indexArg, endArg) {\n    var index = indexArg || 0;\n    var i = -1;\n    var n = array.length - index;\n\n    if (n < 0) {\n        n = 0;\n    }\n\n    if (endArg > 0 && n > endArg) {\n        n = endArg;\n    }\n\n    var array2 = new Array(n);\n    while (++i < n) {\n        array2[i] = array[i + index];\n    }\n    return array2;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/request/flushGetRequest.js":"var pathUtils = require(\"falcor-path-utils\");\nvar toTree = pathUtils.toTree;\nvar toPaths = pathUtils.toPaths;\n\n/**\n * Flushes the current set of requests.  This will send the paths to the\n * dataSource.  * The results of the dataSource will be sent to callback which\n * should perform the zip of all callbacks.\n * @param {GetRequest} request -\n * @param {Array} listOfPaths -\n * @param {Function} callback -\n * @private\n */\nmodule.exports = function flushGetRequest(request, listOfPaths, callback) {\n    if (request._count === 0) {\n        request.requestQueue.removeRequest(request);\n        return;\n    }\n\n    request.sent = true;\n    request.scheduled = false;\n\n    // TODO: Move this to the collapse algorithm,\n    // TODO: we should have a collapse that returns the paths and\n    // TODO: the trees.\n\n    // Take all the paths and add them to the pathMap by length.\n    // Since its a list of paths\n    var pathMap = request._pathMap;\n    var listKeys = Object.keys(listOfPaths);\n    var listIdx = 0, listLen = listKeys.length;\n    for (; listIdx < listLen; ++listIdx) {\n        var paths = listOfPaths[listIdx];\n        for (var j = 0, pathLen = paths.length; j < pathLen; ++j) {\n            var pathSet = paths[j];\n            var len = pathSet.length;\n\n            if (!pathMap[len]) {\n                pathMap[len] = [pathSet];\n            } else {\n                var pathSetsByLength = pathMap[len];\n                pathSetsByLength[pathSetsByLength.length] = pathSet;\n            }\n        }\n    }\n\n    // now that we have them all by length, convert each to a tree.\n    var pathMapKeys = Object.keys(pathMap);\n    var pathMapIdx = 0, pathMapLen = pathMapKeys.length;\n    for (; pathMapIdx < pathMapLen; ++pathMapIdx) {\n        var pathMapKey = pathMapKeys[pathMapIdx];\n        pathMap[pathMapKey] = toTree(pathMap[pathMapKey]);\n    }\n\n    // Take the pathMapTree and create the collapsed paths and send those\n    // off to the server.\n    var collapsedPaths = request._collasped = toPaths(pathMap);\n    var jsonGraphData;\n\n    // Make the request.\n    // You are probably wondering why this is not cancellable.  If a request\n    // goes out, and all the requests are removed, the request should not be\n    // cancelled.  The reasoning is that another request could come in, after\n    // all callbacks have been removed and be deduped.  Might as well keep this\n    // around until it comes back.  If at that point there are no requests then\n    // we cancel at the callback above.\n    request.\n        requestQueue.\n        model._source.\n        get(collapsedPaths).\n        subscribe(function(data) {\n            jsonGraphData = data;\n        }, function(err) {\n            callback(err, jsonGraphData);\n        }, function() {\n            callback(null, jsonGraphData);\n        });\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/ModelResponse.js":"var falcor = require(\"./../\");\n\nvar Rx = require(\"rx/dist/rx\") && require(\"rx/dist/rx.aggregates\");\nvar Observable = Rx.Observable;\n\nvar arraySlice = require(\"./../support/array-slice\");\n\nvar noop = require(\"./../support/noop\");\n\nvar jsongMixin = { outputFormat: { value: \"AsJSONG\" } };\nvar progressiveMixin = { isProgressive: { value: true } };\n\n/**\n * A ModelResponse is a container for the results of a get, set, or call operation performed on a Model. The ModelResponse provides methods which can be used to specify the output format of the data retrieved from a Model, as well as how that data is delivered.\n * @constructor ModelResponse\n * @augments Observable\n*/\nfunction ModelResponse(subscribe) {\n    this._subscribe = subscribe;\n}\n\nModelResponse.create = function create(model, args) {\n    var response = new ModelResponse(subscribeToResponse);\n    // TODO: make these private\n    response.args = args;\n    response.type = this;\n    response.model = model;\n    return response;\n};\n\nModelResponse.prototype = Object.create(Observable.prototype);\n\nModelResponse.prototype.constructor = ModelResponse;\n\nModelResponse.prototype._mixin = function mixin() {\n    var self = this;\n    var mixins = arraySlice(arguments);\n    return new self.constructor(function(observer) {\n        return self.subscribe(mixins.reduce(function(proto, mixin2) {\n            return Object.create(proto, mixin2);\n        }, observer));\n    });\n};\n\n/**\n * Converts the data format of the data in a JSONGraph Model response to a stream of path values.\n * @name toPathValues\n * @memberof ModelResponse.prototype\n * @function\n * @return ModelResponse.<PathValue>\n * @example\nvar model = new falcor.Model({\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\"\n    }\n  }\n});\n\nmodel.\n  get([\"user\",[\"name\", \"surname\"]]).\n  toPathValues().\n  // this method will be called twice, once with the result of [\"user\", \"name\"]\n  // and once with the result of [\"user\", \"surname\"]\n  subscribe(function(pathValue){\n    console.log(JSON.stringify(pathValue));\n  });\n// prints...\n\"{\\\"path\\\":[\\\"user\\\",\\\"name\\\"],\\\"value\\\":\\\"Steve\\\"}\"\n\"{\\\"path\\\":[\\\"user\\\",\\\"surname\\\"],\\\"value\\\":\\\"McGuire\\\"}\"\n */\n\nModelResponse.prototype._toJSONG = function toJSONG() {\n    return this._mixin(jsongMixin);\n};\n\n/**\n * The progressively method breaks the response up into two parts: the data immediately available in the Model cache, and the data in the Model cache after the missing data has been retrieved from the DataSource.\n * The progressively method creates a ModelResponse that immediately returns the requested data that is available in the Model cache. If any requested paths are not available in the cache, the ModelResponse will send another JSON message with all of the requested data after it has been retrieved from the DataSource.\n * @name progressively\n * @memberof ModelResponse.prototype\n * @function\n * @return {ModelResponse.<JSONEnvelope>} the values found at the requested paths.\n * @example\nvar dataSource = (new falcor.Model({\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\",\n      age: 31\n    }\n  }\n})).asDataSource();\n\nvar model = new falcor.Model({\n  source: dataSource,\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\"\n    }\n  }\n});\n\nmodel.\n  get([\"user\",[\"name\", \"surname\", \"age\"]]).\n  progressively().\n  // this callback will be invoked twice, once with the data in the\n  // Model cache, and again with the additional data retrieved from the DataSource.\n  subscribe(function(json){\n    console.log(JSON.stringify(json,null,4));\n  });\n\n// prints...\n// {\n//     \"json\": {\n//         \"user\": {\n//             \"name\": \"Steve\",\n//             \"surname\": \"McGuire\"\n//         }\n//     }\n// }\n// ...and then prints...\n// {\n//     \"json\": {\n//         \"user\": {\n//             \"name\": \"Steve\",\n//             \"surname\": \"McGuire\",\n//             \"age\": 31\n//         }\n//     }\n// }\n*/\nModelResponse.prototype.progressively = function progressively() {\n    return this._mixin(progressiveMixin);\n};\n\nModelResponse.prototype.subscribe = function subscribe(a, b, c) {\n    var observer = a;\n    if (!observer || typeof observer !== \"object\") {\n        observer = { onNext: a || noop, onError: b || noop, onCompleted: c || noop };\n    }\n    var subscription = this._subscribe(observer);\n    switch (typeof subscription) {\n        case \"function\":\n            return { dispose: subscription };\n        case \"object\":\n            return subscription || { dispose: noop };\n        default:\n            return { dispose: noop };\n    }\n};\n\nModelResponse.prototype.then = function then(onNext, onError) {\n    var self = this;\n    return new falcor.Promise(function(resolve, reject) {\n        var value, rejected = false;\n        self.toArray().subscribe(\n            function(values) {\n                if (values.length <= 1) {\n                    value = values[0];\n                } else {\n                    value = values;\n                }\n            },\n            function(errors) {\n                rejected = true;\n                reject(errors);\n            },\n            function() {\n                if (rejected === false) {\n                    resolve(value);\n                }\n            }\n        );\n    }).then(onNext, onError);\n};\n\nfunction subscribeToResponse(observer) {\n\n    var model = this.model;\n    var response = new this.type();\n\n    response.model = model;\n    response.args = this.args;\n    response.outputFormat = observer.outputFormat || \"AsPathMap\";\n    response.isProgressive = observer.isProgressive || false;\n    response.subscribeCount = 0;\n    response.subscribeLimit = observer.retryLimit || 10;\n\n    return (response\n        .initialize()\n        .invokeSourceRequest(model)\n        .ensureCollect(model)\n        .subscribe(observer));\n}\n\nmodule.exports = ModelResponse;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/noop.js":"module.exports = function noop() {};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/SetResponse.js":"var Rx = require(\"rx/dist/rx\");\nvar Observable = Rx.Observable;\nvar Disposable = Rx.Disposable;\nvar GetResponse = require(\"./get/GetResponse\");\nvar IdempotentResponse = require(\"./../response/IdempotentResponse\");\nvar InvalidSourceError = require(\"./../errors/InvalidSourceError\");\n\nvar arrayFlatMap = require(\"./../support/array-flat-map\");\nvar emptyArray = new Array(0);\n\nfunction SetResponse(subscribe) {\n    IdempotentResponse.call(this, subscribe || subscribeToSetResponse);\n}\n\nSetResponse.create = IdempotentResponse.create;\n\nSetResponse.prototype = Object.create(IdempotentResponse.prototype);\nSetResponse.prototype.method = \"set\";\nSetResponse.prototype.constructor = SetResponse;\n\nSetResponse.prototype.invokeSourceRequest = function invokeSourceRequest(model) {\n\n    var source = this;\n    var caught = this.catch(function setJSONGraph(results) {\n\n        var requestObs;\n        if (results && results.invokeSourceRequest === true) {\n\n            var envelope = {};\n            var boundPath = model._path;\n            var optimizedPaths = results.optimizedPaths;\n\n            model._path = emptyArray;\n            model._getPathValuesAsJSONG(model._materialize().withoutDataSource(), optimizedPaths, [envelope]);\n            model._path = boundPath;\n            requestObs = model.\n                _request.set(envelope).\n                do(\n                    function setResponseEnvelope(envelope2) {\n                        source.isCompleted = optimizedPaths.length === envelope2.paths.length;\n                    },\n                    function setResponseError() {\n                        source.isCompleted = true;\n                    }\n                ).\n                materialize().\n                flatMap(function(notification) {\n                    if (notification.kind === \"C\") {\n                        return Observable.empty();\n                    }\n                    if (notification.kind === \"E\") {\n                        var ex = notification.exception;\n                        if (InvalidSourceError.is(ex)) {\n                            return Observable.throw(notification.exception);\n                        }\n                    }\n                    return caught;\n                });\n        }\n        else {\n            requestObs = Observable.throw(results);\n        }\n\n        return requestObs;\n    });\n\n    return new this.constructor(function(observer) {\n        return caught.subscribe(observer);\n    });\n};\n\nfunction subscribeToSetResponse(observer) {\n\n    if (this.isCompleted) {\n        return subscribeToFollowupGet.call(this, observer);\n    }\n\n    return subscribeToLocalSet.call(this, observer);\n}\n\nfunction subscribeToLocalSet(observer) {\n\n    if (this.subscribeCount++ > this.subscribeLimit) {\n        observer.onError(\"Loop kill switch thrown.\");\n        return Disposable.empty;\n    }\n\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var model = this.model;\n    var isMaster = this.isMaster;\n    var modelRoot = model._root;\n    var outputFormat = this.outputFormat;\n    var errorSelector = modelRoot.errorSelector;\n\n    var method = this.method;\n    var groups = this.groups;\n    var groupIndex = -1;\n    var groupCount = groups.length;\n\n    while (++groupIndex < groupCount) {\n\n        var group = groups[groupIndex];\n        var inputType = group.inputType;\n        var methodArgs = group.arguments;\n\n        if (methodArgs.length > 0) {\n\n            var operationName = \"_\" + method + inputType + outputFormat;\n            var operationFunc = model[operationName];\n            var successfulPaths = operationFunc(model, methodArgs, null, errorSelector);\n\n            optimizedPaths.push.apply(optimizedPaths, successfulPaths[1]);\n\n            if (inputType === \"PathValues\") {\n                requestedPaths.push.apply(requestedPaths, methodArgs.map(pluckPath));\n            } else if (inputType === \"JSONGs\") {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(methodArgs, pluckEnvelopePaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, successfulPaths[0]);\n            }\n        }\n    }\n\n    this.requestedPaths = requestedPaths;\n\n    if (isMaster) {\n        this.isCompleted = true;\n        return subscribeToFollowupGet.call(this, observer);\n    } else {\n        observer.onError({\n            method: method,\n            optimizedPaths: optimizedPaths,\n            invokeSourceRequest: true\n        });\n    }\n}\n\nfunction subscribeToFollowupGet(observer) {\n    var response = new GetResponse(this.model, this.requestedPaths);\n    if (this.outputFormat === \"AsJSONG\") {\n        response = response._toJSONG();\n    }\n    if (this.isProgressive) {\n        response = response.progressively();\n    }\n    return response.subscribe(observer);\n}\n\nfunction pluckPath(pathValue) {\n    return pathValue.path;\n}\n\nfunction pluckEnvelopePaths(jsonGraphEnvelope) {\n    return jsonGraphEnvelope.paths;\n}\n\nmodule.exports = SetResponse;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/get/GetResponse.js":"var ModelResponse = require(\"./../ModelResponse\");\nvar checkCacheAndReport = require(\"./checkCacheAndReport\");\nvar getRequestCycle = require(\"./getRequestCycle\");\nvar empty = {dispose: function() {}};\nvar Observable = require(\"rx/dist/rx\").Observable;\n\n/**\n * The get response.  It takes in a model and paths and starts\n * the request cycle.  It has been optimized for cache first requests\n * and closures.\n * @param {Model} model -\n * @param {Array} paths -\n * @private\n */\nvar GetResponse = module.exports = function GetResponse(model, paths,\n                                                        isJSONGraph,\n                                                        isProgressive) {\n    this.model = model;\n    this.currentRemainingPaths = paths;\n    this.isJSONGraph = isJSONGraph || false;\n    this.isProgressive = isProgressive || false;\n};\n\nGetResponse.prototype = Object.create(Observable.prototype);\n\n// becomes a subscribable/thenable from ModelResponse.\nGetResponse.prototype.subscribe = ModelResponse.prototype.subscribe;\nGetResponse.prototype.then = ModelResponse.prototype.then;\n\n/**\n * Makes the output of a get response JSONGraph instead of json.\n * @private\n */\nGetResponse.prototype._toJSONG = function _toJSONGraph() {\n    return new GetResponse(this.model, this.currentRemainingPaths,\n                           true, this.isProgressive);\n};\n\n/**\n * Progressively responding to data in the cache instead of once the whole\n * operation is complete.\n * @public\n */\nGetResponse.prototype.progressively = function progressively() {\n    return new GetResponse(this.model, this.currentRemainingPaths,\n                           this.isJSONGraph, true);\n};\n\n/**\n * purely for the purposes of closure creation other than the initial\n * prototype created closure.\n *\n * @private\n */\nGetResponse.prototype._subscribe = function _subscribe(observer) {\n    var seed = [{}];\n    var errors = [];\n    var isJSONG = observer.isJSONG = this.isJSONGraph;\n    var isProgressive = this.isProgressive;\n    var results = checkCacheAndReport(this.model, this.currentRemainingPaths,\n                                      observer, isProgressive, isJSONG, seed,\n                                      errors);\n\n    // If there are no results, finish.\n    if (!results) {\n        return empty;\n    }\n\n    // Starts the async request cycle.\n    return getRequestCycle(this, this.model, results,\n                           observer, seed, errors, 1);\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/get/checkCacheAndReport.js":"var gets = require(\"./../../get\");\nvar getWithPathsAsJSONGraph = gets.getWithPathsAsJSONGraph;\nvar getWithPathsAsPathMap = gets.getWithPathsAsPathMap;\n\n/**\n * Checks cache for the paths and reports if in progressive mode.  If\n * there are missing paths then return the cache hit results.\n *\n * @param {Model} model - The model that the request was made with.\n * @param {Array} requestedMissingPaths -\n * @param {Boolean} progressive -\n * @param {Boolean} isJSONG -\n * @param {Function} onNext -\n * @param {Function} onError -\n * @param {Function} onCompleted -\n * @param {Object} seed - The state of the output\n * @private\n */\nmodule.exports = function checkCacheAndReport(model, requestedPaths, observer,\n                                              progressive, isJSONG, seed,\n                                              errors) {\n\n    // checks the cache for the data.\n    var results;\n    if (isJSONG) {\n        results = getWithPathsAsJSONGraph(model, requestedPaths, seed);\n    } else {\n        results = getWithPathsAsPathMap(model, requestedPaths, seed);\n    }\n\n    // We must communicate critical errors from get that are critical\n    // errors such as bound path is broken or this is a JSONGraph request\n    // with a bound path.\n    if (results.criticalError) {\n        observer.onError(results.criticalError);\n        return null;\n    }\n\n    // We are done when there are no missing paths or the model does not\n    // have a dataSource to continue on fetching from.\n    var hasValues = results.hasValue;\n    var completed = !results.requestedMissingPaths || !model._source;\n    var hasValueOverall = seed[0].json || seed[0].jsonGraph;\n\n    // Copy the errors into the total errors array.\n    if (results.errors) {\n        var errs = results.errors;\n        var errorsLength = errors.length;\n        for (var i = 0, len = errs.length; i < len; ++i, ++errorsLength) {\n            errors[errorsLength] = errs[i];\n        }\n    }\n\n    // If there are values to report, then report.\n\n    if (hasValues && progressive || hasValueOverall && completed) {\n        // TODO: Remove the sync counter\n        try {\n            ++model._root.syncRefCount;\n            observer.onNext(seed[0]);\n        } catch(e) {\n            throw e;\n        } finally {\n            --model._root.syncRefCount;\n        }\n    }\n\n    // if there are missing paths, then lets return them.\n    if (completed) {\n        if (errors.length) {\n            observer.onError(errors);\n        } else {\n            observer.onCompleted();\n        }\n\n        return null;\n    }\n\n    // Return the results object.\n    return results;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/index.js":"var get = require(\"./get\");\nvar walkPath = require(\"./walkPath\");\n\nvar getWithPathsAsPathMap = get(walkPath, false);\nvar getWithPathsAsJSONGraph = get(walkPath, true);\n\nmodule.exports = {\n    getValueSync: require(\"./../get/getValueSync\"),\n    getBoundValue: require(\"./../get/getBoundValue\"),\n    getWithPathsAsPathMap: getWithPathsAsPathMap,\n    getWithPathsAsJSONGraph: getWithPathsAsJSONGraph\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/get.js":"var getCachePosition = require(\"./../get/getCachePosition\");\nvar InvalidModelError = require(\"./../errors/InvalidModelError\");\nvar BoundJSONGraphModelError = require(\"./../errors/BoundJSONGraphModelError\");\n\nmodule.exports = function get(walk, isJSONG) {\n    return function innerGet(model, paths, seed) {\n        var valueNode = seed[0];\n        var results = {\n            values: seed,\n            optimizedPaths: []\n        };\n        var cache = model._root.cache;\n        var boundPath = model._path;\n        var currentCachePosition = cache;\n        var optimizedPath, optimizedLength = boundPath.length;\n        var i, len;\n        var requestedPath = [];\n\n        // If the model is bound, then get that cache position.\n        if (optimizedLength) {\n\n            // JSONGraph output cannot ever be bound or else it will\n            // throw an error.\n            if (isJSONG) {\n                return {\n                    criticalError: new BoundJSONGraphModelError()\n                };\n            }\n            currentCachePosition = getCachePosition(model, boundPath);\n\n            // If there was a short, then we 'throw an error' to the outside\n            // calling function which will onError the observer.\n            if (currentCachePosition.$type) {\n                return {\n                    criticalError: new InvalidModelError(boundPath, boundPath)\n                };\n            }\n\n            // We need to get the new cache position and copy the bound\n            // path.\n            optimizedPath = [];\n            for (i = 0; i < optimizedLength; ++i) {\n                optimizedPath[i] = boundPath[i];\n            }\n        }\n\n        // Update the optimized path if we\n        else {\n            optimizedPath = [];\n            optimizedLength = 0;\n        }\n\n        for (i = 0, len = paths.length; i < len; i++) {\n            walk(model, cache, currentCachePosition, paths[i], 0,\n                 valueNode, results, requestedPath, optimizedPath,\n                 optimizedLength, isJSONG);\n        }\n        return results;\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/getCachePosition.js":"/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = function getCachePosition(model, path) {\n    var currentCachePosition = model._root.cache;\n    var depth = -1;\n    var maxDepth = path.length;\n\n    // The loop is simple now, we follow the current cache position until\n    //\n    while (++depth < maxDepth &&\n           currentCachePosition && !currentCachePosition.$type) {\n\n        currentCachePosition = currentCachePosition[path[depth]];\n    }\n\n    return currentCachePosition;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/errors/BoundJSONGraphModelError.js":"/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nfunction BoundJSONGraphModelError() {\n    this.message = BoundJSONGraphModelError.message;\n    this.stack = (new Error()).stack;\n}\n\n// instanceof will be an error, but stack will be correct because its defined in the constructor.\nBoundJSONGraphModelError.prototype = new Error();\nBoundJSONGraphModelError.prototype.name = \"BoundJSONGraphModelError\";\nBoundJSONGraphModelError.message =\n    \"It is not legal to use the JSON Graph \" +\n    \"format from a bound Model. JSON Graph format\" +\n    \" can only be used from a root model.\";\n\nmodule.exports = BoundJSONGraphModelError;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/walkPath.js":"var followReference = require(\"./followReference\");\nvar onValueType = require(\"./onValueType\");\nvar isExpired = require(\"./util/isExpired\");\nvar iterateKeySet = require(\"falcor-path-utils\").iterateKeySet;\nvar $ref = require(\"./../types/ref\");\nvar promote = require(\"./util/lru\").promote;\n\nmodule.exports = function walkPath(model, root, curr, path, depth, seed,\n                                   outerResults, requestedPath,\n                                   optimizedPathArg, optimizedLength, isJSONG,\n                                   fromReferenceArg) {\n\n    var fromReference = fromReferenceArg;\n    var optimizedPath = optimizedPathArg;\n\n    // If there is not a value in the current cache position or its a\n    // value type, then we are at the end of the getWalk.\n    if ((!curr || curr && curr.$type) || depth === path.length) {\n        onValueType(model, curr, path, depth, seed, outerResults,\n                requestedPath, optimizedPath, optimizedLength,\n                isJSONG, fromReference);\n        return;\n    }\n\n    var keySet, i;\n    keySet = path[depth];\n\n    var isKeySet = typeof keySet === \"object\";\n    var nextDepth = depth + 1;\n    var iteratorNote = false;\n    var key = keySet;\n    if (isKeySet) {\n        iteratorNote = {};\n        key = iterateKeySet(keySet, iteratorNote);\n    }\n\n    // The key can be undefined if there is an empty path.  An example of an\n    // empty path is: [lolomo, [], summary]\n    if (key === undefined && iteratorNote.done) {\n        return;\n    }\n\n    // loop over every key over the keySet\n    var optimizedLengthPlus1 = optimizedLength + 1;\n    do {\n        fromReference = false;\n\n        var next;\n\n        if (key === null) {\n            next = curr;\n        }\n        else {\n            next = curr[key];\n            optimizedPath[optimizedLength] = key;\n            requestedPath[depth] = key;\n        }\n\n        var nextOptimizedPath = optimizedPath;\n        var nextOptimizedLength = optimizedLengthPlus1;\n\n        // If there is the next position we need to consider references.\n        if (next) {\n            var nType = next.$type;\n            var value = nType && next.value || next;\n\n            // If next is a reference follow it.  If we are in JSONG mode,\n            // report that value into the seed without passing the requested\n            // path.  If a requested path is passed to onValueType then it\n            // will add that path to the JSONGraph envelope under `paths`\n            if (nextDepth < path.length && nType &&\n                nType === $ref && !isExpired(next)) {\n                if (isJSONG) {\n                    onValueType(model, next, path, nextDepth, seed,\n                                outerResults, null, optimizedPath,\n                                nextOptimizedLength, isJSONG, fromReference);\n                }\n\n                // promote the reference so that it will not be cleaned out of\n                // the cache when its heavily used.\n                promote(model, next);\n                var ref = followReference(model, root, root, next,\n                                          value, seed, isJSONG);\n                fromReference = true;\n                next = ref[0];\n                var refPath = ref[1];\n                nextOptimizedPath = [];\n                nextOptimizedLength = refPath.length;\n                for (i = 0; i < nextOptimizedLength; ++i) {\n                    nextOptimizedPath[i] = refPath[i];\n                }\n            }\n        }\n\n        // Recurse to the next level.\n        walkPath(model, root, next, path, nextDepth, seed, outerResults,\n                requestedPath, nextOptimizedPath, nextOptimizedLength,\n                isJSONG, fromReference);\n\n        // If the iteratorNote is not done, get the next key.\n        if (iteratorNote && !iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n\n    } while (iteratorNote && !iteratorNote.done);\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/onValueType.js":"var isExpired = require(\"./util/isExpired\");\nvar hardLink = require(\"./util/hardlink\");\nvar lru = require(\"./util/lru\");\nvar removeHardlink = hardLink.remove;\nvar splice = lru.splice;\nvar $error = require(\"./../types/error\");\nvar onError = require(\"./onError\");\nvar onValue = require(\"./onValue\");\nvar onMissing = require(\"./onMissing\");\nvar isMaterialized = require(\"./util/isMaterialzed\");\nvar __invalidated = require(\"./../internal/invalidated\");\n\n/**\n * When we land on a valueType (or nothing) then we need to report it out to\n * the outerResults through errors, missing, or values.\n *\n * @private\n */\nmodule.exports = function onValueType(\n    model, node, path, depth, seed, outerResults,\n    requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference) {\n\n    var currType = node && node.$type;\n    var requiresMaterializedToReport = node && node.value === undefined;\n\n    // There are is nothing here, ether report value, or report the value\n    // that is missing.  If there is no type then report the missing value.\n    if (!node || !currType) {\n        if (isMaterialized(model)) {\n            onValue(model, node, seed, depth, outerResults,\n                    requestedPath, optimizedPath, optimizedLength,\n                    isJSONG, fromReference);\n        } else {\n            onMissing(model, path, depth,\n                      outerResults, requestedPath,\n                      optimizedPath, optimizedLength);\n        }\n        return;\n    }\n\n    // If there are expired value, then report it as missing\n    else if (isExpired(node)) {\n        if (!node[__invalidated]) {\n            splice(model, node);\n            removeHardlink(node);\n        }\n        onMissing(model, path, depth,\n                  outerResults, requestedPath,\n                  optimizedPath, optimizedLength);\n    }\n\n    // If there is an error, then report it as a value if\n    else if (currType === $error) {\n        if (fromReference) {\n            requestedPath[depth] = null;\n        }\n        if (isJSONG || model._treatErrorsAsValues) {\n            onValue(model, node, seed, depth, outerResults, requestedPath,\n                    optimizedPath, optimizedLength, isJSONG, fromReference);\n        } else {\n            onError(model, node, depth, requestedPath, outerResults);\n        }\n    }\n\n    // Report the value\n    else {\n        if (fromReference) {\n            requestedPath[depth] = null;\n        }\n\n        if (!requiresMaterializedToReport ||\n            requiresMaterializedToReport && model._materialized) {\n\n            onValue(model, node, seed, depth, outerResults, requestedPath,\n                    optimizedPath, optimizedLength, isJSONG, fromReference);\n        }\n    }\n};\n\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/onError.js":"var lru = require(\"./../get/util/lru\");\nvar clone = require(\"./../get/util/clone\");\nvar promote = lru.promote;\n\nmodule.exports = function onError(model, node, depth,\n                                  requestedPath, outerResults) {\n    var value = node.value;\n    if (!outerResults.errors) {\n        outerResults.errors = [];\n    }\n\n    if (model._boxed) {\n        value = clone(node);\n    }\n    outerResults.errors.push({\n        path: requestedPath.slice(0, depth + 1),\n        value: value\n    });\n    promote(model, node);\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/onMissing.js":"var support = require(\"./util/support\");\nvar fastCopy = support.fastCopy;\n\nmodule.exports = function onMissing(model, path, depth,\n                                    outerResults, requestedPath,\n                                    optimizedPath, optimizedLength) {\n    var pathSlice;\n    if (!outerResults.requestedMissingPaths) {\n        outerResults.requestedMissingPaths = [];\n        outerResults.optimizedMissingPaths = [];\n    }\n\n    if (depth < path.length) {\n        pathSlice = fastCopy(path, depth);\n    } else {\n        pathSlice = [];\n    }\n\n    concatAndInsertMissing(model, pathSlice, depth, requestedPath,\n                           optimizedPath, optimizedLength, outerResults);\n};\n\nfunction concatAndInsertMissing(model, remainingPath, depth, requestedPath,\n                                optimizedPath, optimizedLength, results) {\n\n    // TODO: Performance.\n    results.requestedMissingPaths.push(\n        requestedPath.\n            slice(0, depth).\n            concat(remainingPath));\n\n    results.optimizedMissingPaths.push(\n        optimizedPath.slice(0, optimizedLength).concat(remainingPath));\n}\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/util/support.js":"function fastCopy(arr, iArg) {\n    var a = [], len, j, i;\n    for (j = 0, i = iArg || 0, len = arr.length; i < len; j++, i++) {\n        a[j] = arr[i];\n    }\n    return a;\n}\n\nfunction fastCatSkipNulls(arr1, arr2) {\n    var a = [], i, len, j;\n    for (i = 0, len = arr1.length; i < len; i++) {\n        a[i] = arr1[i];\n    }\n    for (j = 0, len = arr2.length; j < len; j++) {\n        if (arr2[j] !== null) {\n            a[i++] = arr2[j];\n        }\n    }\n    return a;\n}\n\nfunction fastCat(arr1, arr2) {\n    var a = [], i, len, j;\n    for (i = 0, len = arr1.length; i < len; i++) {\n        a[i] = arr1[i];\n    }\n    for (j = 0, len = arr2.length; j < len; j++) {\n        a[i++] = arr2[j];\n    }\n    return a;\n}\n\n\n\nmodule.exports = {\n    fastCat: fastCat,\n    fastCatSkipNulls: fastCatSkipNulls,\n    fastCopy: fastCopy\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/util/isMaterialzed.js":"module.exports = function isMaterialized(model) {\n    return model._materialized && !model._source;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/get/getRequestCycle.js":"var checkCacheAndReport = require(\"./checkCacheAndReport\");\nvar MaxRetryExceededError = require(\"./../../errors/MaxRetryExceededError\");\nvar fastCat = require(\"./../../get/util/support\").fastCat;\nvar collectLru = require(\"./../../lru/collect\");\nvar getSize = require(\"./../../support/getSize\");\nvar AssignableDisposable = require(\"./AssignableDisposable\");\nvar __version = require(\"./../../internal/version\");\n\n/**\n * The get request cycle for checking the cache and reporting\n * values.  If there are missing paths then the async request cycle to\n * the data source is performed until all paths are resolved or max\n * requests are made.\n * @param {GetResponse} getResponse -\n * @param {Model} model - The model that the request was made with.\n * @param {Object} results -\n * @param {Function} onNext -\n * @param {Function} onError -\n * @param {Function} onCompleted -\n * @param {Object} seedArg - The state of the output\n * @private\n */\nmodule.exports = function getRequestCycle(getResponse, model, results, observer,\n                                          seed, errors, count) {\n    // we have exceeded the maximum retry limit.\n    if (count === 10) {\n        throw new MaxRetryExceededError();\n    }\n\n    var requestQueue = model._request;\n    var requestedMissingPaths = results.requestedMissingPaths;\n    var optimizedMissingPaths = results.optimizedMissingPaths;\n    var disposable = new AssignableDisposable();\n\n    // We need to prepend the bound path to all requested missing paths and\n    // pass those into the requestQueue.\n    var boundRequestedMissingPaths = [];\n    var boundPath = model._path;\n    if (boundPath.length) {\n        for (var i = 0, len = requestedMissingPaths.length; i < len; ++i) {\n            boundRequestedMissingPaths[i] =\n                fastCat(boundPath, requestedMissingPaths[i]);\n        }\n    }\n\n    // No bound path, no array copy and concat.\n    else {\n        boundRequestedMissingPaths = requestedMissingPaths;\n    }\n\n    var currentRequestDisposable = requestQueue.\n        get(boundRequestedMissingPaths, optimizedMissingPaths, function() {\n\n\n            // Once the request queue finishes, check the cache and bail if\n            // we can.\n            var nextResults = checkCacheAndReport(model, requestedMissingPaths,\n                                                  observer,\n                                                  getResponse.isProgressive,\n                                                  getResponse.isJSONGraph,\n                                                  seed, errors);\n\n            // If there are missing paths coming back form checkCacheAndReport\n            // the its reported from the core cache check method.\n            if (nextResults) {\n\n                // update the which disposable to use.\n                disposable.currentDisposable =\n                    getRequestCycle(getResponse, model, nextResults, observer,\n                                    seed, errors, count + 1);\n            }\n\n            // We have finished.  Since we went to the dataSource, we must\n            // collect on the cache.\n            else {\n\n                var modelRoot = model._root;\n                var modelCache = modelRoot.cache;\n                var currentVersion = modelCache[__version];\n\n                collectLru(modelRoot, modelRoot.expired, getSize(modelCache),\n                        model._maxSize, model._collectRatio, currentVersion);\n            }\n\n        });\n    disposable.currentDisposable = currentRequestDisposable;\n    return disposable;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/errors/MaxRetryExceededError.js":"var NAME = \"MaxRetryExceededError\";\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @private\n */\nfunction MaxRetryExceededError() {\n    this.message = \"The allowed number of retries have been exceeded.\";\n    this.stack = (new Error()).stack;\n}\n\n// instanceof will be an error, but stack will be correct because its defined\n// in the constructor.\nMaxRetryExceededError.prototype = new Error();\nMaxRetryExceededError.prototype.name = NAME;\nMaxRetryExceededError.is = function(e) {\n    return e && e.name === NAME;\n};\n\nmodule.exports = MaxRetryExceededError;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/lru/collect.js":"var __key = require(\"./../internal/key\");\nvar __parent = require(\"./../internal/parent\");\n\nvar __head = require(\"./../internal/head\");\nvar __tail = require(\"./../internal/tail\");\nvar __next = require(\"./../internal/next\");\nvar __prev = require(\"./../internal/prev\");\n\nvar removeNode = require(\"./../support/removeNode\");\nvar updateNodeAncestors = require(\"./../support/updateNodeAncestors\");\n\nmodule.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== \"number\") {\n        ratio = 0.75;\n    }\n\n    var shouldUpdate = typeof version === \"number\";\n    var targetSize = max * ratio;\n    var parent, node, size;\n\n    node = expired.pop();\n\n    while (node) {\n        size = node.$size || 0;\n        total -= size;\n        if (shouldUpdate === true) {\n            updateNodeAncestors(node, size, lru, version);\n        } else if (parent = node[__parent]) {\n            removeNode(node, parent, node[__key], lru);\n        }\n        node = expired.pop();\n    }\n\n    if (total >= max) {\n        var prev = lru[__tail];\n        node = prev;\n        while ((total >= targetSize) && node) {\n            prev = prev[__prev];\n            size = node.$size || 0;\n            total -= size;\n            if (shouldUpdate === true) {\n                updateNodeAncestors(node, size, lru, version);\n            }\n            node = prev;\n        }\n\n        lru[__tail] = lru[__prev] = node;\n        if (node == null) {\n            lru[__head] = lru[__next] = void 0;\n        } else {\n            node[__next] = void 0;\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/get/AssignableDisposable.js":"/**\n * Will allow for state tracking of the current disposable.  Also fulfills the\n * disposable interface.\n * @private\n */\nvar AssignableDisposable = function AssignableDisposable(disosableCallback) {\n    this.disposed = false;\n    this.currentDisposable = disosableCallback;\n};\n\n\nAssignableDisposable.prototype = {\n\n    /**\n     * Disposes of the current disposable.  This would be the getRequestCycle\n     * disposable.\n     */\n    dispose: function dispose() {\n        if (this.disposed || !this.currentDisposable) {\n            return;\n        }\n        this.disposed = true;\n\n        // If the current disposable fulfills the disposable interface or just\n        // a disposable function.\n        var currentDisposable = this.currentDisposable;\n        if (currentDisposable.dispose) {\n            currentDisposable.dispose();\n        }\n\n        else {\n            currentDisposable();\n        }\n    }\n};\n\n\nmodule.exports = AssignableDisposable;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/IdempotentResponse.js":"var Rx = require(\"rx/dist/rx\");\nvar Observable = Rx.Observable;\n\nvar ModelResponse = require(\"./../response/ModelResponse\");\n\nvar pathSyntax = require(\"falcor-path-syntax\");\n\nvar getSize = require(\"./../support/getSize\");\nvar collectLru = require(\"./../lru/collect\");\n\nvar arrayClone = require(\"./../support/array-clone\");\nvar __version = require(\"./../internal/version\");\n\nvar isArray = Array.isArray;\nvar isPathValue = require(\"./../support/isPathValue\");\nvar isJSONEnvelope = require(\"./../support/isJSONEnvelope\");\nvar isJSONGraphEnvelope = require(\"./../support/isJSONGraphEnvelope\");\n\nfunction IdempotentResponse(subscribe) {\n    Observable.call(this, subscribe);\n}\n\nIdempotentResponse.create = ModelResponse.create;\n\nIdempotentResponse.prototype = Object.create(Observable.prototype);\nIdempotentResponse.prototype.constructor = IdempotentResponse;\n\nIdempotentResponse.prototype.subscribeCount = 0;\nIdempotentResponse.prototype.subscribeLimit = 10;\n\nIdempotentResponse.prototype.initialize = function initializeResponse() {\n\n    var model = this.model;\n    var outputFormat = this.outputFormat || \"AsPathMap\";\n    var isProgressive = this.isProgressive;\n    var values = [{}];\n\n    var groups = [];\n    var args = this.args;\n\n    var group, groupType;\n\n    var argIndex = -1;\n    var argCount = args.length;\n\n    // Validation of arguments have been moved out of this function.\n    while (++argIndex < argCount) {\n        var arg = args[argIndex];\n        var argType;\n        if (isArray(arg) || typeof arg === \"string\") {\n            arg = pathSyntax.fromPath(arg);\n            argType = \"PathValues\";\n        } else if (isPathValue(arg)) {\n            arg.path = pathSyntax.fromPath(arg.path);\n            argType = \"PathValues\";\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = \"JSONGs\";\n        } else if (isJSONEnvelope(arg)) {\n            argType = \"PathMaps\";\n        }\n        if (groupType !== argType) {\n            groupType = argType;\n            group = {\n                inputType: argType,\n                arguments: []\n            };\n            groups.push(group);\n            group.values = values;\n        }\n\n        group.arguments.push(arg);\n    }\n\n    this.boundPath = arrayClone(model._path);\n    this.groups = groups;\n    this.outputFormat = outputFormat;\n    this.isProgressive = isProgressive;\n    this.isCompleted = false;\n    this.isMaster = model._source == null;\n    this.values = values;\n\n    return this;\n};\n\nIdempotentResponse.prototype.invokeSourceRequest = function invokeSourceRequest(model) {\n    return this;\n};\n\nIdempotentResponse.prototype.ensureCollect = function ensureCollect(model) {\n    var ensured = this.finally(function ensureCollect() {\n\n        var modelRoot = model._root;\n        var modelCache = modelRoot.cache;\n\n        modelRoot.collectionScheduler.schedule(function collectThisPass() {\n            collectLru(modelRoot, modelRoot.expired, getSize(modelCache),\n                model._maxSize, model._collectRatio, modelCache[__version]);\n        });\n    });\n\n    return new this.constructor(function(observer) {\n        return ensured.subscribe(observer);\n    });\n};\n\nmodule.exports = IdempotentResponse;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/array-clone.js":"module.exports = function arrayClone(array) {\n    if (!array) {\n        return array;\n    }\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        array2[i] = array[i];\n    }\n    return array2;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/isPathValue.js":"var isArray = Array.isArray;\nvar isObject = require(\"./../support/isObject\");\n\nmodule.exports = function isPathValue(pathValue) {\n    return isObject(pathValue) && (\n        isArray(pathValue.path) || (\n            typeof pathValue.path === \"string\"\n        ));\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/isJSONEnvelope.js":"var isObject = require(\"./../support/isObject\");\n\nmodule.exports = function isJSONEnvelope(envelope) {\n    return isObject(envelope) && (\"json\" in envelope);\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/isJSONGraphEnvelope.js":"var isArray = Array.isArray;\nvar isObject = require(\"./../support/isObject\");\n\nmodule.exports = function isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (\n        isObject(envelope.jsonGraph) ||\n        isObject(envelope.jsong) ||\n        isObject(envelope.json) ||\n        isObject(envelope.values) ||\n        isObject(envelope.value)\n    );\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/array-flat-map.js":"module.exports = function arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/CallResponse.js":"var Rx = require(\"rx/dist/rx\") && require(\"rx/dist/rx.aggregates\");\nvar Observable = Rx.Observable;\nvar CompositeDisposable = Rx.CompositeDisposable;\n\nvar ModelResponse = require(\"./../response/ModelResponse\");\nvar InvalidSourceError = require(\"./../errors/InvalidSourceError\");\n\nvar pathSyntax = require(\"falcor-path-syntax\");\n\nvar $ref = require(\"./../types/ref\");\n\nfunction CallResponse(subscribe) {\n    Observable.call(this, subscribe || subscribeToResponse);\n}\n\nCallResponse.create = ModelResponse.create;\n\nCallResponse.prototype = Object.create(Observable.prototype);\nCallResponse.prototype.constructor = CallResponse;\n\nCallResponse.prototype.invokeSourceRequest = function invokeSourceRequest(model) {\n    return this;\n};\n\nCallResponse.prototype.ensureCollect = function ensureCollect(model) {\n    return this;\n};\n\nCallResponse.prototype.initialize = function initializeResponse() {\n    return this;\n};\n\nfunction toObservable(x) {\n    return Rx.Observable.defer(function() {\n        return x;\n    });\n}\n\nfunction subscribeToResponse(observer) {\n\n    var args = this.args;\n    var model = this.model;\n\n    var callPath = pathSyntax.fromPath(args[0]);\n    var callArgs = args[1] || [];\n    var suffixes = (args[2] || []).map(pathSyntax.fromPath);\n    var extraPaths = (args[3] || []).map(pathSyntax.fromPath);\n\n    var rootModel = model._clone({\n        _path: []\n    });\n    var localRoot = rootModel.withoutDataSource();\n    var boundPath = model._path;\n    var boundCallPath = boundPath.concat(callPath);\n    var boundThisPath = boundCallPath.slice(0, -1);\n\n    var setCallValuesObs = toObservable(\n            model.withoutDataSource().get(callPath)\n        )\n        .map(function(data) {\n            var curr = data.json;\n            var depth = -1;\n            var length = callPath.length;\n\n            while (curr && ++depth < length) {\n                curr = curr[callPath[depth]];\n            }\n            var boundModel = rootModel._derefSync(boundThisPath).boxValues();\n            return {\n                model: boundModel,\n                localFn: curr\n            };\n        })\n        .flatMap(getLocalCallObs)\n        .defaultIfEmpty(getRemoteCallObs(model._source))\n        .mergeAll()\n        .flatMap(setCallEnvelope);\n\n    var disposables = new CompositeDisposable();\n\n    disposables.add(setCallValuesObs.subscribe(function(envelope) {\n            var paths = envelope.paths;\n            var invalidated = envelope.invalidated;\n            var innerObs = model.get.apply(model, paths);\n            if (observer.outputFormat === \"AsJSONG\") {\n                innerObs = toObservable(innerObs._toJSONG()).doAction(function(envelope2) {\n                    envelope2.invalidated = invalidated;\n                });\n            }\n            disposables.add(innerObs.subscribe(observer));\n        },\n        function(e) {\n            observer.onError(e);\n        }\n    ));\n\n    return disposables;\n\n    function getLocalCallObs(tuple) {\n\n        var localFn = tuple && tuple.localFn;\n\n        if (typeof localFn === \"function\") {\n\n            var localFnModel = tuple.model;\n            var localThisPath = localFnModel._path;\n\n            var remoteGetValues = localFn\n                .apply(localFnModel, callArgs)\n                .reduce(aggregateFnResults, {\n                    values: [],\n                    references: [],\n                    invalidations: [],\n                    localThisPath: localThisPath\n                })\n                .flatMap(setLocalValues)\n                .flatMap(getRemoteValues);\n\n            return Observable.return(remoteGetValues);\n        }\n\n        return Observable.empty();\n\n        function aggregateFnResults(results, pathValue) {\n            if (Boolean(pathValue.invalidated)) {\n                results.invalidations.push(results.localThisPath.concat(pathValue.path));\n            } else {\n                var path = pathValue.path;\n                var value = pathValue.value;\n                if (Boolean(value) && typeof value === \"object\" && value.$type === $ref) {\n                    results.references.push({\n                        path: prependThisPath(path),\n                        value: pathValue.value\n                    });\n                } else {\n                    results.values.push({\n                        path: prependThisPath(path),\n                        value: pathValue.value\n                    });\n                }\n            }\n            return results;\n        }\n\n        function setLocalValues(results) {\n            var values = results.values.concat(results.references);\n            if (values.length > 0) {\n                return toObservable(localRoot.set.\n                        apply(localRoot, values).\n                        _toJSONG())\n                    .map(function(envelope) {\n                        return {\n                            results: results,\n                            envelope: envelope\n                        };\n                    });\n            } else {\n                return Observable.return({\n                    results: results,\n                    envelope: {\n                        jsonGraph: {},\n                        paths: []\n                    }\n                });\n            }\n        }\n\n        function getRemoteValues(tuple2) {\n\n            var envelope = tuple2.envelope;\n            var results = tuple2.results;\n            var values = results.values;\n            var references = results.references;\n            var invalidations = results.invalidations;\n\n            var rootValues = values.map(pluckPath).map(prependThisPath);\n            var rootSuffixes = references.reduce(prependRefToSuffixes, []);\n            var rootExtraPaths = extraPaths.map(prependThisPath);\n            var rootPaths = rootSuffixes.concat(rootExtraPaths);\n            var envelopeObs;\n\n            if (rootPaths.length > 0) {\n                envelopeObs = toObservable(rootModel.get.apply(rootModel, rootValues.concat(rootPaths))._toJSONG());\n            } else {\n                envelopeObs = Observable.return(envelope);\n            }\n\n            return envelopeObs.doAction(function(envelope2) {\n                envelope2.invalidated = invalidations;\n            });\n        }\n\n        function prependRefToSuffixes(refPaths, refPathValue) {\n            var refPath = refPathValue.path;\n            refPaths.push.apply(refPaths, suffixes.map(function(pathSuffix) {\n                return refPath.concat(pathSuffix);\n            }));\n            return refPaths;\n        }\n\n        function pluckPath(pathValue) {\n            return pathValue.path;\n        }\n    }\n\n    function getRemoteCallObs(dataSource) {\n\n        if (dataSource && typeof dataSource === \"object\") {\n            return Rx.Observable.defer(function() {\n                var obs;\n                try {\n                    obs = dataSource.call(boundCallPath, callArgs, suffixes, extraPaths);\n                } catch (e) {\n                    obs = Observable.throw(new InvalidSourceError(e));\n                }\n                return obs;\n            }).map(invalidateLocalValues);\n        }\n\n        return Observable.empty();\n\n        function invalidateLocalValues(envelope) {\n            var invalidations = envelope.invalidated;\n            if (invalidations && invalidations.length) {\n                rootModel.invalidate.apply(rootModel, invalidations);\n            }\n            return envelope;\n        }\n    }\n\n    function setCallEnvelope(envelope) {\n        return toObservable(localRoot.set(envelope)).\n            reduce(function(acc) { return acc; }, null).\n            map(function() {\n                return {\n                    invalidated: envelope.invalidated,\n                    paths: envelope.paths.map(function(path) {\n                        return path.slice(boundPath.length);\n                    })\n                };\n            });\n    }\n\n    function prependThisPath(path) {\n        return boundThisPath.concat(path);\n    }\n}\n\nmodule.exports = CallResponse;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/InvalidateResponse.js":"var Rx = require(\"rx/dist/rx\");\nvar Disposable = Rx.Disposable;\n\nvar IdempotentResponse = require(\"./../response/IdempotentResponse\");\n\nfunction InvalidateResponse(subscribe) {\n    IdempotentResponse.call(this, subscribe || subscribeToInvalidateResponse);\n}\n\nInvalidateResponse.create = IdempotentResponse.create;\n\nInvalidateResponse.prototype = Object.create(IdempotentResponse.prototype);\nInvalidateResponse.prototype.method = \"invalidate\";\nInvalidateResponse.prototype.constructor = InvalidateResponse;\n\nfunction subscribeToInvalidateResponse(observer) {\n\n    var model = this.model;\n    var method = this.method;\n\n    var groups = this.groups;\n    var groupIndex = -1;\n    var groupCount = groups.length;\n\n    while (++groupIndex < groupCount) {\n\n        var group = groups[groupIndex];\n        var inputType = group.inputType;\n        var methodArgs = group.arguments;\n\n        if (methodArgs.length > 0) {\n            var operationName = \"_\" + method + inputType + \"AsJSON\";\n            var operationFunc = model[operationName];\n            operationFunc(model, methodArgs);\n        }\n    }\n\n    observer.onCompleted();\n\n    return Disposable.empty;\n}\n\nmodule.exports = InvalidateResponse;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/schedulers/ASAPScheduler.js":"var asap = require(\"asap\");\nvar Rx = require(\"rx/dist/rx\");\nvar Disposable = Rx.Disposable;\n\nfunction ASAPScheduler() {}\n\nASAPScheduler.prototype.schedule = function schedule(action) {\n    asap(action);\n    return Disposable.empty;\n};\n\nASAPScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {\n    var self = this;\n    asap(function() {\n        action(self, state);\n    });\n    return Disposable.empty;\n};\n\nmodule.exports = ASAPScheduler;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/schedulers/TimeoutScheduler.js":"var Rx = require(\"rx/dist/rx\");\nvar Disposable = Rx.Disposable;\n\nfunction TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    var id = setTimeout(action, this.delay);\n    return Disposable.create(function() {\n        if (id !== void 0) {\n            clearTimeout(id);\n            id = void 0;\n        }\n    });\n};\n\nTimeoutScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {\n    var self = this;\n    var id = setTimeout(function() {\n        action(self, state);\n    }, this.delay);\n    return Disposable.create(function() {\n        if (id !== void 0) {\n            clearTimeout(id);\n            id = void 0;\n        }\n    });\n};\n\nmodule.exports = TimeoutScheduler;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/set/setPathMaps.js":"var __key = require(\"./../internal/key\");\nvar __ref = require(\"./../internal/ref\");\nvar __prefix = require(\"./../internal/prefix\");\nvar __parent = require(\"./../internal/parent\");\nvar __context = require(\"./../internal/context\");\nvar __version = require(\"./../internal/version\");\nvar __refIndex = require(\"./../internal/ref-index\");\nvar __refsLength = require(\"./../internal/refs-length\");\n\nvar $ref = require(\"./../types/ref\");\n\nvar getBoundValue = require(\"./../get/getBoundValue\");\n\nvar isArray = Array.isArray;\nvar promote = require(\"./../lru/promote\");\nvar hasOwn = require(\"./../support/hasOwn\");\nvar isObject = require(\"./../support/isObject\");\nvar isExpired = require(\"./../support/isExpired\");\nvar isFunction = require(\"./../support/isFunction\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar expireNode = require(\"./../support/expireNode\");\nvar incrementVersion = require(\"./../support/incrementVersion\");\nvar mergeValueOrInsertBranch = require(\"./../support/mergeValueOrInsertBranch\");\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n * @return {Array.<Path>} - a list of optimized paths for the successfully set values.\n */\n\nmodule.exports = function setPathMaps(model, pathMapEnvelopes, x, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = bound.length ? getBoundValue(model, bound).value : cache;\n    var parent = node[__parent] || cache;\n    var initialVersion = cache[__version];\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    var newVersion = cache[__version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(\n    pathMap, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = isObject(child) && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(\n                root, parent, node, key, child,\n                branch, false, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            optimizedPath[optimizedPath.index++] = key;\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                        version, expired, lru, comparator, errorSelector\n                    );\n                } else {\n                    promote(lru, nextNode);\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var reference = node.value;\n    optimizedPath.splice(0, optimizedPath.length);\n    optimizedPath.push.apply(optimizedPath, reference);\n\n    if (isExpired(node)) {\n        optimizedPath.index = reference.length;\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    promote(lru, node);\n\n    var container = node;\n    var parent = root;\n\n    node = node[__context];\n\n    if (node != null) {\n        parent = node[__parent] || root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = setNode(\n                root, parent, node, key, value,\n                branch, true, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n            node = results[0];\n            if (isPrimitive(node)) {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container[__context] !== node) {\n            var backRefs = node[__refsLength] || 0;\n            node[__refsLength] = backRefs + 1;\n            node[__ref + backRefs] = container;\n            container[__context] = node;\n            container[__refIndex] = backRefs;\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node[__key];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    node = mergeValueOrInsertBranch(\n        parent, node, key, value,\n        branch, reference, requestedPath, optimizedPath,\n        version, expired, lru, comparator, errorSelector\n    );\n\n    return [node, parent];\n}\n\nfunction getKeys(pathMap) {\n\n    if (isObject(pathMap) && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = \"length\";\n        }\n        for (var key in pathMap) {\n            if (key[0] === __prefix || key[0] === \"$\" || !hasOwn(pathMap, key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return void 0;\n}\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/validateInput.js":"var isArray = Array.isArray;\nvar isPathValue = require(\"./../support/isPathValue\");\nvar isJSONGraphEnvelope = require(\"./../support/isJSONGraphEnvelope\");\nvar isJSONEnvelope = require(\"./../support/isJSONEnvelope\");\nvar pathSyntax = require(\"falcor-path-syntax\");\n\n/**\n *\n * @param {Object} allowedInput - allowedInput is a map of input styles\n * that are allowed\n * @private\n */\nmodule.exports = function validateInput(args, allowedInput, method) {\n    for (var i = 0, len = args.length; i < len; ++i) {\n        var arg = args[i];\n        var valid = false;\n\n        // Path\n        if (isArray(arg) && allowedInput.path) {\n            valid = true;\n        }\n\n        // Path Syntax\n        else if (typeof arg === \"string\" && allowedInput.pathSyntax) {\n            valid = true;\n        }\n\n        // Path Value\n        else if (isPathValue(arg) && allowedInput.pathValue) {\n            arg.path = pathSyntax.fromPath(arg.path);\n            valid = true;\n        }\n\n        // jsonGraph {jsonGraph: { ... }, paths: [ ... ]}\n        else if (isJSONGraphEnvelope(arg) && allowedInput.jsonGraph) {\n            valid = true;\n        }\n\n        // json env {json: {...}}\n        else if (isJSONEnvelope(arg) && allowedInput.json) {\n            valid = true;\n        }\n\n        // selector functions\n        else if (typeof arg === \"function\" &&\n                 i + 1 === len &&\n                 allowedInput.selector) {\n            valid = true;\n        }\n\n        if (!valid) {\n            return new Error(\"Unrecognized argument \" + (typeof arg) + \" [\" + String(arg) + \"] \" + \"to Model#\" + method + \"\");\n        }\n    }\n    return true;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/getCache.js":"var $modelCreated = require(\"./../internal/model-created\");\nvar isInternalKey = require(\"./../support/isInternalKey\");\n\n/**\n * decends and copies the cache.\n */\nmodule.exports = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (!isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    Object.\n        keys(node).\n        filter(function(k) {\n            // Its not an internal key and the node has a value.  In the cache\n            // there are 3 possibilities for values.\n            // 1: A branch node.\n            // 2: A $type-value node.\n            // 3: undefined\n            // We will strip out 3\n            return !isInternalKey(k) && node[k];\n        }).\n        forEach(function(key) {\n            var cacheNext = node[key];\n            var outNext = out[key];\n\n            if (!outNext) {\n                outNext = out[key] = {};\n            }\n\n            // Paste the node into the out cache.\n            if (cacheNext.$type) {\n                var isObject = cacheNext.value && typeof cacheNext.value === \"object\";\n                var isUserCreatedcacheNext = !node[$modelCreated];\n                var value;\n                if (isObject || isUserCreatedcacheNext) {\n                    value = cloneBoxedValue(cacheNext);\n                } else {\n                    value = cacheNext.value;\n                }\n\n                out[key] = value;\n                return;\n            }\n\n            _copyCache(cacheNext, outNext, key);\n        });\n}\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/isInternalKey.js":"var prefix = require(\"./../internal/prefix\");\n\n/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\nmodule.exports = function isInternalKey(x) {\n    return (x === \"$size\") || (x && (x.charAt(0) === prefix));\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/get/validInput.js":"module.exports = {\n    path: true,\n    pathSyntax: true\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/get/index.js":"var pathSyntax = require(\"falcor-path-syntax\");\nvar ModelResponse = require(\"./../ModelResponse\");\nvar GET_VALID_INPUT = require(\"./validInput\");\nvar validateInput = require(\"./../../support/validateInput\");\nvar GetResponse = require(\"./GetResponse\");\n\n/**\n * Performs a get on the cache and if there are missing paths\n * then the request will be forwarded to the get request cycle.\n * @private\n */\nmodule.exports = function get() {\n    // Validates the input.  If the input is not pathSets or strings then we\n    // will onError.\n    var out = validateInput(arguments, GET_VALID_INPUT, \"get\");\n    if (out !== true) {\n        return new ModelResponse(function(o) {\n            o.onError(out);\n        });\n    }\n\n    var paths = pathSyntax.fromPathsOrPathValues(arguments);\n    return new GetResponse(this, paths);\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/get/getWithPaths.js":"var GetResponse = require(\"./GetResponse\");\n\n/**\n * Performs a get on the cache and if there are missing paths\n * then the request will be forwarded to the get request cycle.\n * @private\n */\nmodule.exports = function getWithPaths(paths) {\n    return new GetResponse(this, paths);\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/deref/index.js":"var Rx = require(\"rx/dist/rx\");\nvar pathSyntax = require(\"falcor-path-syntax\");\n\nmodule.exports = function deref(boundPathArg) {\n\n    var model = this;\n    var pathsIndex = -1;\n    var pathsCount = arguments.length - 1;\n    var paths = new Array(pathsCount);\n\n    var boundPath = pathSyntax.fromPath(boundPathArg);\n\n    while (++pathsIndex < pathsCount) {\n        paths[pathsIndex] = pathSyntax.fromPath(arguments[pathsIndex + 1]);\n    }\n\n    if (pathsCount === 0) {\n        throw new Error(\"Model#deref requires at least one value path.\");\n    }\n\n    return Rx.Observable.defer(function() {\n        return derefSync(model, boundPath);\n    }).\n    flatMap(function(boundModel) {\n        if (Boolean(boundModel)) {\n            if (pathsCount > 0) {\n                var ofBoundModel = Rx.Observable.of(boundModel);\n\n                // Ensures that all the leaves are in the cache.\n                return boundModel.get.\n                    apply(boundModel, paths).\n\n                    // Ensures that if only errors occur, then the concat\n                    // will still run.\n                    catch(Rx.Observable.empty()).\n\n                    // Ensures that the last thing returned by this operation is\n                    // the bound model.\n                    concat(ofBoundModel).\n\n                    // Plucks the last value from this stream, which should be\n                    // the bound model.\n                    last().\n\n                    // Chooses the new deref or passes on the invalid model\n                    // error.\n                    flatMap(function getNextBoundModel() {\n\n                        // TODO: Should we onError the error from derefSync?\n                        return derefSync(model, boundPath);\n                    }).\n\n                    // The previous operation can undefine the cache, so we need\n                    // to ensure that we don't return and undefined model.\n                    filter(function(x) { return x; });\n            }\n            return Rx.Observable.return(boundModel);\n        } else if (pathsCount > 0) {\n            var modifiedPaths = paths.map(function(path) {\n                return boundPath.concat(path);\n            });\n\n            // Fill the cache with the request.\n            return model.\n                get.apply(model, modifiedPaths).\n\n                // We concat the deref sync operation afterwords.\n                // Any errors will be forwarded onto the caller.\n                concat(Rx.Observable.defer(function() {\n                    return derefSync(model, boundPath);\n                })).\n                last().\n\n                // 'x' has to exist.  Cannot be falsy.  Must be model.\n                filter(function(x) { return x; });\n        }\n        return Rx.Observable.empty();\n    });\n};\n\nfunction derefSync(model, boundPath) {\n    var value;\n    var errorHappened = false;\n    try {\n        ++model._root.syncRefCount;\n        value = model._derefSync(boundPath);\n    } catch (e) {\n        value = e;\n        errorHappened = true;\n    } finally {\n        --model._root.syncRefCount;\n    }\n    return errorHappened ?\n        Rx.Observable.throw(value) :\n        Rx.Observable.return(value);\n}\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/getValue.js":"var ModelResponse = require(\"./../response/ModelResponse\");\nvar pathSyntax = require(\"falcor-path-syntax\");\n\nmodule.exports = function getValue(path) {\n    var parsedPath = pathSyntax.fromPath(path);\n    var pathIdx = 0;\n    var pathLen = parsedPath.length;\n    while (++pathIdx < pathLen) {\n        if (typeof parsedPath[pathIdx] === \"object\") {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function(o) {\n                o.onError(new Error(\"Paths must be simple paths\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n\n    var self = this;\n    return new ModelResponse(function(obs) {\n        return self.get(parsedPath).subscribe(function(data) {\n            var curr = data.json;\n            var depth = -1;\n            var length = parsedPath.length;\n\n            while (curr && ++depth < length) {\n                curr = curr[parsedPath[depth]];\n            }\n            obs.onNext(curr);\n        }, function(err) {\n            obs.onError(err);\n        }, function() {\n            obs.onCompleted();\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/set/setValue.js":"var jsong = require(\"falcor-json-graph\");\nvar ModelResponse = require(\"./../response/ModelResponse\");\nvar isPathValue = require(\"./../support/isPathValue\");\n\nmodule.exports = function setValue(pathArg, valueArg) {\n    var value = isPathValue(pathArg) ? pathArg : jsong.pathValue(pathArg, valueArg);\n    var pathIdx = 0;\n    var path = value.path;\n    var pathLen = path.length;\n    while (++pathIdx < pathLen) {\n        if (typeof path[pathIdx] === \"object\") {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function(o) {\n                o.onError(new Error(\"Paths must be simple paths\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n    var self = this;\n    return new ModelResponse(function(obs) {\n        return self._set(value).subscribe(function(data) {\n            var curr = data.json;\n            var depth = -1;\n            var length = path.length;\n\n            while (curr && ++depth < length) {\n                curr = curr[path[depth]];\n            }\n            obs.onNext(curr);\n        }, function(err) {\n            obs.onError(err);\n        }, function() {\n            obs.onCompleted();\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/sync.js":"var pathSyntax = require(\"falcor-path-syntax\");\n\nmodule.exports = function getValueSync(pathArg) {\n    var path = pathSyntax.fromPath(pathArg);\n    if (Array.isArray(path) === false) {\n        throw new Error(\"Model#getValueSync must be called with an Array path.\");\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._syncCheck(\"getValueSync\") && this._getValueSync(this, path).value;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/set/sync.js":"var pathSyntax = require(\"falcor-path-syntax\");\nvar isPathValue = require(\"./../support/isPathValue\");\nvar setPathValues = require(\"./../set/setPathValues\");\n\nmodule.exports = function setValueSync(pathArg, valueArg, errorSelectorArg, comparatorArg) {\n\n    var path = pathSyntax.fromPath(pathArg);\n    var value = valueArg;\n    var errorSelector = errorSelectorArg;\n    var comparator = comparatorArg;\n\n    if (isPathValue(path)) {\n        comparator = errorSelector;\n        errorSelector = value;\n        value = path;\n    } else {\n        value = {\n            path: path,\n            value: value\n        };\n    }\n\n    if (isPathValue(value) === false) {\n        throw new Error(\"Model#setValueSync must be called with an Array path.\");\n    }\n\n    if (typeof errorSelector !== \"function\") {\n        errorSelector = this._root._errorSelector;\n    }\n\n    if (typeof comparator !== \"function\") {\n        comparator = this._root._comparator;\n    }\n\n    if (this._syncCheck(\"setValueSync\")) {\n        setPathValues(this, [value]);\n        return this._getValueSync(this, value.path).value;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/deref/sync.js":"var pathSyntax = require(\"falcor-path-syntax\");\nvar getBoundValue = require(\"./../get/getBoundValue\");\nvar InvalidModelError = require(\"./../errors/InvalidModelError\");\nvar $atom = require(\"./../types/atom\");\n\nmodule.exports = function derefSync(boundPathArg) {\n\n    var boundPath = pathSyntax.fromPath(boundPathArg);\n\n    if (!Array.isArray(boundPath)) {\n        throw new Error(\"Model#derefSync must be called with an Array path.\");\n    }\n\n    var boundValue = getBoundValue(this, this._path.concat(boundPath), false);\n\n    var path = boundValue.path;\n    var node = boundValue.value;\n    var found = boundValue.found;\n\n    // If the node is not found or the node is found but undefined is returned,\n    // this happens when a reference is expired.\n    if (!found || node === undefined ||\n        node.$type === $atom && node.value === undefined) {\n        return undefined;\n    }\n\n    if (node.$type) {\n        throw new InvalidModelError();\n    }\n\n    return this._clone({ _path: path });\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/getVersion.js":"var __version = require(\"./../internal/version\");\n\nmodule.exports = function _getVersion(model, path) {\n    // ultra fast clone for boxed values.\n    var gen = model._getValueSync({\n        _boxed: true,\n        _root: model._root,\n        _treatErrorsAsValues: model._treatErrorsAsValues\n    }, path, true).value;\n    var version = gen && gen[__version];\n    return (version == null) ? -1 : version;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/invalidate/invalidatePathSets.js":"var __key = require(\"./../internal/key\");\nvar __ref = require(\"./../internal/ref\");\nvar __parent = require(\"./../internal/parent\");\nvar __context = require(\"./../internal/context\");\nvar __version = require(\"./../internal/version\");\nvar __refIndex = require(\"./../internal/ref-index\");\nvar __refsLength = require(\"./../internal/refs-length\");\n\nvar $ref = require(\"./../types/ref\");\n\nvar getBoundValue = require(\"./../get/getBoundValue\");\n\nvar promote = require(\"./../lru/promote\");\nvar getSize = require(\"./../support/getSize\");\nvar isExpired = require(\"./../support/isExpired\");\nvar isFunction = require(\"./../support/isFunction\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar expireNode = require(\"./../support/expireNode\");\nvar iterateKeySet = require(\"falcor-path-utils\").iterateKeySet;\nvar incrementVersion = require(\"./../support/incrementVersion\");\nvar updateNodeAncestors = require(\"./../support/updateNodeAncestors\");\nvar removeNodeAndDescendants = require(\"./../support/removeNodeAndDescendants\");\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = function invalidatePathSets(model, paths) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = bound.length ? getBoundValue(model, bound).value : cache;\n    var parent = node[__parent] || cache;\n    var initialVersion = cache[__version];\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(\n            path, 0, cache, parent, node,\n            version, expired, lru\n        );\n    }\n\n    var newVersion = cache[__version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathSet(\n    path, depth, root, parent, node,\n    version, expired, lru) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        var results = invalidateNode(\n            root, parent, node,\n            key, branch, false,\n            version, expired, lru\n        );\n        var nextNode = results[0];\n        var nextParent = results[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(\n                    path, depth + 1,\n                    root, nextParent, nextNode,\n                    version, expired, lru\n                );\n            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, node, version, expired, lru) {\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    promote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[__context];\n\n    if (node != null) {\n        parent = node[__parent] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(\n                root, parent, node,\n                key, branch, true,\n                version, expired, lru\n            );\n            node = results[0];\n            if (isPrimitive(node)) {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container[__context] !== node) {\n            var backRefs = node[__refsLength] || 0;\n            node[__refsLength] = backRefs + 1;\n            node[__ref + backRefs] = container;\n            container[__context] = node;\n            container[__refIndex] = backRefs;\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, branch, reference,\n    version, expired, lru) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(root, node, version, expired, lru);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node[__key];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/invalidate/invalidatePathMaps.js":"var __key = require(\"./../internal/key\");\nvar __ref = require(\"./../internal/ref\");\nvar __prefix = require(\"./../internal/prefix\");\nvar __parent = require(\"./../internal/parent\");\nvar __context = require(\"./../internal/context\");\nvar __version = require(\"./../internal/version\");\nvar __refIndex = require(\"./../internal/ref-index\");\nvar __refsLength = require(\"./../internal/refs-length\");\n\nvar $ref = require(\"./../types/ref\");\n\nvar getBoundValue = require(\"./../get/getBoundValue\");\n\nvar promote = require(\"./../lru/promote\");\nvar getSize = require(\"./../support/getSize\");\nvar hasOwn = require(\"./../support/hasOwn\");\nvar isObject = require(\"./../support/isObject\");\nvar isExpired = require(\"./../support/isExpired\");\nvar isFunction = require(\"./../support/isFunction\");\nvar isPrimitive = require(\"./../support/isPrimitive\");\nvar expireNode = require(\"./../support/expireNode\");\nvar incrementVersion = require(\"./../support/incrementVersion\");\nvar updateNodeAncestors = require(\"./../support/updateNodeAncestors\");\nvar removeNodeAndDescendants = require(\"./../support/removeNodeAndDescendants\");\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = function invalidatePathMaps(model, pathMapEnvelopes) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var comparator = modelRoot._comparator;\n    var errorSelector = modelRoot._errorSelector;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = bound.length ? getBoundValue(model, bound).value : cache;\n    var parent = node[__parent] || cache;\n    var initialVersion = cache[__version];\n\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    var newVersion = cache[__version];\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, errorSelector) {\n\n    if (isPrimitive(pathMap) || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (key[0] !== __prefix && key[0] !== \"$\" && hasOwn(pathMap, key)) {\n            var child = pathMap[key];\n            var branch = isObject(child) && !child.$type;\n            var results = invalidateNode(\n                root, parent, node,\n                key, child, branch, false,\n                version, expired, lru, comparator, errorSelector\n            );\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        version, expired, lru, comparator, errorSelector\n                    );\n                } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                    updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector) {\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    promote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node[__context];\n\n    if (node != null) {\n        parent = node[__parent] || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(\n                root, parent, node,\n                key, value, branch, true,\n                version, expired, lru, comparator, errorSelector\n            );\n            node = results[0];\n            if (isPrimitive(node)) {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container[__context] !== node) {\n            var backRefs = node[__refsLength] || 0;\n            node[__refsLength] = backRefs + 1;\n            node[__ref + backRefs] = container;\n            container[__context] = node;\n            container[__refIndex] = backRefs;\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, value, branch, reference,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node[__key];\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/HttpDataSource.js":"\n/**\n * A HttpDataSource object is a {@link DataSource} can be used to retrieve data from a remote JSONGraph object using the browser's XMLHttpRequest.\n * @constructor HttpDataSource\n * @augments DataSource\n * @param jsonGraphUrl the URL of the JSONGraph model.\n * @example\nvar model = new falcor.Model({source: new falcor.HttpDataSource(\"http://netflix.com/user.json\")});\nvar movieNames = model.get('genreLists[0...10][0...10].name').toPathValues();\n */\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/get/SHORTED.js":"/**\n * The SHORTED constant.  Since what is returned from a\n * cache position lookop will always be an object, any non\n * object will do fine for a constant.\n * @private\n */\nmodule.exports = 1;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/internal/offset.js":"module.exports = require(\"./../internal/prefix\") + \"offset\";\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/request/BatchedRequest.js":"var Rx = require(\"rx/dist/rx\") && require(\"rx/dist/rx.binding\");\nvar Observable = Rx.Observable;\nvar immediateScheduler = Rx.Scheduler.immediate;\n\nvar Request = require(\"./../request/Request\");\n\nfunction BatchedRequest() {\n    Request.call(this);\n}\n\nBatchedRequest.create = Request.create;\n\nBatchedRequest.prototype = Object.create(Request.prototype);\nBatchedRequest.prototype.constructor = BatchedRequest;\n\nBatchedRequest.prototype.getSourceObservable = function getSourceObservable() {\n\n    if (this.refCountedObservable) {\n        return this.refCountedObservable;\n    }\n\n    var count = 0;\n    var source = this;\n    var subject = new Rx.ReplaySubject(null, null, immediateScheduler);\n    var connection = null;\n    var refCountedObservable = Observable.create(function subscribe(observer) {\n        if (++count === 1 && !connection) {\n            connection = source.subscribe(subject);\n        }\n        var subscription = subject.subscribe(observer);\n        return function dispose() {\n            subscription.dispose();\n            if (--count === 0) {\n                connection.dispose();\n            }\n        };\n    });\n\n    this.refCountedObservable = refCountedObservable;\n\n    return refCountedObservable;\n};\n\nmodule.exports = BatchedRequest;\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/response/updateProgressively.js":"var isFunction = require(\"falcor/support/isFunction\");\n\nmodule.exports = function updateProgressively() {\n    var source = this;\n    return new source.constructor(function subscribeProgressively(observer) {\n\n        var destOnNext = observer.onNext;\n        var destOnError = observer.onError;\n        var destOnCompleted = observer.onCompleted;\n\n        observer.onNext = observer.asPathValues ? onPathValueNext : onAggregateNext;\n        observer.onError = onError;\n        observer.onCompleted = onCompleted;\n\n        return source.subscribe(observer);\n\n        function onError(e) {\n            destOnError.call(observer, e);\n        }\n\n        function onCompleted() {\n            destOnCompleted.call(observer);\n        }\n\n        function onPathValueNext(pathValue) {\n            destOnNext.call(observer, pathValue);\n        }\n\n        function onAggregateNext(observer2) {\n\n            var hasValue = observer2.hasValue;\n            var hasError = observer2.hasError;\n            var isCompleted = observer2.isCompleted;\n            var isProgressive = observer2.isProgressive;\n\n            if (hasValue && (isCompleted || isProgressive)) {\n                var model = observer2.model;\n                var values = observer2.values;\n                var selector = observer2.selector;\n                if (isFunction(selector)) {\n                    destOnNext.call(observer2, selector.apply(model, values.map(pluckJSON)));\n                } else {\n                    destOnNext.call(observer2, values[0]);\n                }\n            }\n\n            if (isCompleted) {\n                if (hasError) {\n                    onError(observer2.errors);\n                } else {\n                    onCompleted();\n                }\n            } else {\n                onError(observer2);\n            }\n        }\n    });\n};\n\nfunction pluckJSON(env) {\n    return env.json;\n}\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/array-append.js":"module.exports = function arrayAppend(array, value) {\n    var i = -1;\n    var n = array.length;\n    var array2 = new Array(n + 1);\n    while (++i < n) {\n        array2[i] = array[i];\n    }\n    array2[i] = value;\n    return array2;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/array-concat.js":"module.exports = function arrayConcat(array, other) {\n    if (!array) {\n        return other;\n    }\n    var i = -1,\n        j = -1;\n    var n = array.length;\n    var m = other.length;\n    var array2 = new Array(n + m);\n    while (++i < n) {\n        array2[i] = array[i];\n    }\n    while (++j < m) {\n        array2[i++] = other[j];\n    }\n    return array2;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/identity.js":"module.exports = function identity(x) {\n    return x;\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/support/isPathInvalidation.js":"var isObject = require(\"./../support/isObject\");\n\nmodule.exports = function isPathInvalidation(pathValue) {\n    return isObject(pathValue) && (typeof pathValue.invalidated === \"boolean\");\n};\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/Atom.js":"/**\n * An atom allows you to treat a JSON value as atomic regardless of its type, ensuring that a JSON object or array is always returned in its entirety. The JSON value must be treated as immutable. Atoms can also be used to associate metadata with a JSON value. This metadata can be used to influence the way values are handled.\n * @typedef {Object} Atom\n * @property {!String} $type - the $type must be \"atom\"\n * @property {!*} value - the immutable JSON value\n * @property {number} [$expires] - the time to expire in milliseconds\n *  - positive number: expires in milliseconds since epoch\n *  - negative number: expires relative to when the Atom is merged into the JSONGraph\n *  - number 1: never expires\n * @example\n // Atom with number value, expiring in 2 seconds\n {\n    $type: \"atom\",\n    value: 5\n    $expires: -2000\n }\n // Atom with Object value that never expires\n {\n    $type: \"atom\",\n    value: {\n        foo: 5,\n        bar: \"baz\"\n    },\n    $expires: 1\n }\n */\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/DataSource.js":"/**\n * A DataSource is an interface which can be implemented to expose JSON Graph information to a Model. Every DataSource is associated with a single JSON Graph object. Models execute JSON Graph operations (get, set, and call) to retrieve values from the DataSource’s JSON Graph object. DataSources may retrieve JSON Graph information from anywhere, including device memory, a remote machine, or even a lazily-run computation.\n * @constructor DataSource\n * @abstract\n*/\n\n\n/**\n * The get method retrieves values from the DataSource's associated JSONGraph object.\n * @name get\n * @function\n * @arg {Array.<PathSet>} pathSets the path(s) to retrieve\n * @returns {Observable.<JSONGraphEnvelope>} jsonGraphEnvelope the response returned from the server.\n * @memberof DataSource.prototype\n*/\n\n/**\n * The set method accepts values to set in the DataSource's associated JSONGraph object.\n * @name set\n * @function\n * @arg {JSONGraphEnvelope} jsonGraphEnvelope a JSONGraphEnvelope containing values to set in the DataSource's associated JSONGraph object.\n * @returns {Observable.<JSONGraphEnvelope>} a JSONGraphEnvelope containing all of the requested values after the set operation.\n * @memberof DataSource.prototype\n*/\n\n/**\n * Invokes a function in the DataSource's JSONGraph object.\n * @name call\n * @function\n * @arg {Path} functionPath the path to the function to invoke\n * @arg {Array.<Object>} args the arguments to pass to the function\n * @arg {Array.<PathSet>} refSuffixes paths to retrieve from the targets of JSONGraph References in the function's response.\n * @arg {Array.<PathSet>} thisPaths paths to retrieve from function's this object after successful function execution\n * @returns {Observable.<JSONGraphEnvelope>} jsonGraphEnvelope the response returned from the server.\n * @memberof DataSource.prototype\n*/\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/JSONEnvelope.js":"/**\n * An envelope that wraps a JSON object.\n * @typedef {Object} JSONEnvelope\n * @property {JSON} json - a JSON object\n * @example\n var model = new falcor.Model();\n model.set({\n    json: {\n      name: \"Steve\",\n      surname: \"McGuire\"\n    }\n }).then(function(jsonEnvelope) {\n    console.log(jsonEnvelope);\n });\n */\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/JSONGraphEnvelope.js":"/**\n * An envelope that wraps a {@link JSONGraph} fragment.\n * @typedef {Object} JSONGraphEnvelope\n * @property {JSONGraph} jsonGraph - a {@link JSONGraph} fragment\n * @property {?Array.<PathSet>} paths - the paths to the values in the {@link JSONGraph} fragment\n * @property {?Array.<PathSet>} invalidated - the paths to invalidate in the {@link Model}\n * @example\nvar $ref = falcor.ref;\nvar model = new falcor.Model();\nmodel.set({\n  paths: [\n    [\"todos\", [12,15], [\"name\",\"done\"]]\n  ],\n  jsonGraph: {\n    todos: [\n      $ref(\"todosById[12]\"),\n      $ref(\"todosById[15]\")\n    ],\n    todosById: {\n      12: {\n        name: \"go to the ATM\",\n        done: false\n      },\n      15: {\n        name: \"buy milk\",\n        done: false\n      }\n    }\n  },\n}).then(function(jsonEnvelope) {\n  console.log(JSON.stringify(jsonEnvelope, null, 4));\n});\n\n// prints...\n// {\n//   json: {\n//     todos: {\n//       0: {\n//         name: \"go to the ATM\",\n//         done: false\n//       },\n//       1: {\n//         name: \"buy milk\",\n//         done: false\n//       }\n//     }\n//   }\n// }\n */\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/JSONGraph.js":"/**\n * JavaScript Object Notation Graph (JSONGraph) is a notation for expressing graphs in JSON. For more information, see the [JSONGraph Guide]{@link http://netflix.github.io/falcor/documentation/jsongraph.html}.\n * @typedef {Object} JSONGraph\n * @example\n var $ref = falcor.ref;\n // JSONGraph model modeling a list of film genres, each of which contains the same title.\n {\n    // list of user's genres, modeled as a map with ordinal keys\n    \"genreLists\": {\n        \"0\": $ref('genresById[123]'),\n        \"1\": $ref('genresById[522]'),\n        \"length\": 2\n    },\n    // map of all genres, organized by ID\n    \"genresById\": {\n        // genre list modeled as map with ordinal keys\n        \"123\": {\n            \"name\": \"Drama\",\n            \"0\": $ref('titlesById[23]'),\n            \"1\": $ref('titlesById[99]'),\n            \"length\": 2\n        },\n        // genre list modeled as map with ordinal keys\n        \"522\": {\n            \"name\": \"Comedy\",\n            \"0\": $ref('titlesById[23]'),\n            \"1\": $ref('titlesById[44]'),\n            \"length\": 2\n        }\n    },\n    // map of all titles, organized by ID\n    \"titlesById\": {\n       \"99\": {\n            \"name\": \"House of Cards\",\n            \"rating\": 5\n        },\n        \"23\": {\n            \"name\": \"Orange is the New Black\",\n            \"rating\": 5\n        },\n        \"44\": {\n            \"name\": \"Arrested Development\",\n            \"rating\": 5\n        }\n    }\n}\n*/\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/Key.js":"/**\n * A part of a {@link Path} that can be any JSON value type. All types are coerced to string, except null. This makes the number 1 and the string \"1\" equivalent.\n * @typedef {?(string|number|boolean|null)} Key\n */\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/KeySet.js":"/**\n * A part of a {@link PathSet} that can be either a {@link Key}, {@link Range}, or Array of either.\n * @typedef {(Key|Range|Array.<(Key|Range)>)} KeySet\n */\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/Observable.js":"\n/**\n * @constructor Observable\n */\n\n /**\n * The forEach method is a synonym for {@link Observable.prototype.subscribe} and triggers the execution of the Observable, causing the values within to be pushed to a callback. An Observable is like a pipe of water that is closed. When forEach is called, we open the valve and the values within are pushed at us.  These values can be received using either callbacks or an {@link Observer} object.\n * @name forEach\n * @memberof Observable.prototype\n * @function\n * @arg {?Observable~onNextCallback} onNext a callback that accepts the next value in the stream of values\n * @arg {?Observable~onErrorCallback} onError a callback that accepts an error that occurred while evaluating the operation underlying the {@link Observable} stream\n * @arg {?Observable~onCompletedCallback} onCompleted a callback that is invoked when the {@link Observable} stream has ended, and the {@link Observable~onNextCallback} will not receive any more values\n * @return {Subscription}\n */\n\n /**\n * The subscribe method is a synonym for {@link Observable.prototype.forEach} and triggers the execution of the Observable, causing the values within to be pushed to a callback. An Observable is like a pipe of water that is closed. When forEach is called, we open the valve and the values within are pushed at us.  These values can be received using either callbacks or an {@link Observer} object.\n * @name forEach\n * @memberof Observable.prototype\n * @function\n * @arg {?Observable~onNextCallback} onNext a callback that accepts the next value in the stream of values\n * @arg {?Observable~onErrorCallback} onError a callback that accepts an error that occurred while evaluating the operation underlying the {@link Observable} stream\n * @arg {?Observable~onCompletedCallback} onCompleted a callback that is invoked when the {@link Observable} stream has ended, and the {@link Observable~onNextCallback} will not receive any more values\n * @return {Subscription}\n */\n\n/**\n * This callback accepts a value that was emitted while evaluating the operation underlying the {@link Observable} stream.\n * @callback Observable~onNextCallback\n * @param {Object} value the value that was emitted while evaluating the operation underlying the {@link Observable}\n */\n\n/**\n * This callback accepts an error that occurred while evaluating the operation underlying the {@link Observable} stream. When this callback is invoked, the {@link Observable} stream ends and no more values will be received by the {@link Observable~onNextCallback}.\n * @callback Observable~onErrorCallback\n * @param {Error} error the error that occurred while evaluating the operation underlying the {@link Observable}\n */\n\n /**\n * This callback is invoked when the {@link Observable} stream ends. When this callback is invoked the {@link Observable} stream has ended, and therefore the {@link Observable~onNextCallback} will not receive any more values.\n * @callback Observable~onCompletedCallback\n */\n\n/**\n * @constructor Subscription\n * @see {@link https://github.com/Reactive-Extensions/RxJS/tree/master/doc}\n */\n\n/**\n * When this method is called on the Subscription, the Observable that created the Subscription will stop sending values to the callbacks passed when the Subscription was created.\n * @name dispose\n * @method\n * @memberof Subscription.prototype\n */\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/Path.js":"/**\n * An ordered list of {@link Key}s that point to a value in a {@link JSONGraph}.\n * @typedef {Array.<Key>} Path\n * @example\n // Points to the name of product 1234\n [\"productsById\", \"1234\", \"name\"]\n */\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/PathSet.js":"/**\n * An ordered list of {@link KeySet}s that point to location(s) in the {@link JSONGraph}. It enables pointing to multiple locations in a more terse format than a set of {@link Path}s and is generally more efficient to evaluate.\n * @typedef {Array.<KeySet>} PathSet\n * @example\n // Points to the name and price of products 1234 and 5678\n [\"productsById\", [\"1234\", \"5678\"], [\"name\", \"price\"]]\n */\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/PathValue.js":"/**\n * A wrapper around a path and its value.\n * @typedef {Object} PathValue\n * @property {PathSet} path - the path to a location in the {@link JSONGraph}\n * @property {?*} value - the value of that path\n * @example\n {\n\tpath: [\"productsById\", \"1234\", \"name\"],\n\tvalue: \"ABC\"\n }\n */\n","/home/travis/build/npmtest/node-npmtest-falcor/node_modules/falcor/lib/typedefs/Range.js":"/**\n * Describe a range of integers. Must contain either a \"to\" or \"length\" property.\n * @typedef {Object} Range\n * @property {number} [from=0] - the lower bound of the range (inclusive)\n * @property {?number} to - the upper bound of the range (inclusive). Must be >= to the \"from\" value\n * @property {?number} length - the length of the range. Must be >= 0\n * @example\n // The following range specifies the numbers 0, 1, and 2\n {from: 0, to: 2}\n // The following range specifies the numbers 1 and 2\n {from: 1, length: 2}\n */\n"}